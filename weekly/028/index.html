<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="前端进阶导航(2021版) Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="前端进阶导航(2021版) Blog Atom Feed"><title data-react-helmet="true">28. 精读《2017前端性能优化备忘录》 🦖 前端进阶导航(2021版)</title><meta data-react-helmet="true" property="og:url" content="https://coder-study-room.github.io/weekly/028"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-weekly-current"><meta data-react-helmet="true" property="og:title" content="28. 精读《2017前端性能优化备忘录》 🦖 前端进阶导航(2021版)"><meta data-react-helmet="true" name="description" content="本期精读的文章是：Front End Performance Checklist 2017"><meta data-react-helmet="true" property="og:description" content="本期精读的文章是：Front End Performance Checklist 2017"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://coder-study-room.github.io/weekly/028"><link data-react-helmet="true" rel="alternate" href="https://coder-study-room.github.io/weekly/028" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://coder-study-room.github.io/weekly/028" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f86f321e.css">
<link rel="preload" href="/assets/js/styles.b3f043dc.js" as="script">
<link rel="preload" href="/assets/js/runtime~main.b93be3da.js" as="script">
<link rel="preload" href="/assets/js/main.fb8f3d2b.js" as="script">
<link rel="preload" href="/assets/js/1.46fdb85d.js" as="script">
<link rel="preload" href="/assets/js/2.37941b87.js" as="script">
<link rel="preload" href="/assets/js/3.8e957956.js" as="script">
<link rel="preload" href="/assets/js/1be78505.4595a7b1.js" as="script">
<link rel="preload" href="/assets/js/397.3ed54396.js" as="script">
<link rel="preload" href="/assets/js/cc953bd4.972fd30a.js" as="script">
<link rel="preload" href="/assets/js/17896441.136bed3d.js" as="script">
<link rel="preload" href="/assets/js/cbfd5a2e.62d3e796.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">前端进阶导航(2021版)</strong></a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link">前端学习</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/">前端进阶</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/weekly/">前端精读</a></li></ul></div><a class="navbar__item navbar__link" href="/interview/">前端面试</a></div><div class="navbar__items navbar__items--right"><a href="https://juejin.cn/user/149189280672616/posts" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">掘金</a><a href="https://www.itdongdong.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">博客</a><a href="https://www.aliyun.com/minisite/goods?userCode=656jmlbm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">阿里云2折</a><a href="https://github.com/coder-study-room/Front-end-Advanced-Route" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">前端进阶导航(2021版)</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist">前端学习</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">前端进阶</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/weekly/">前端精读</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/interview/">前端面试</a></li><li class="menu__list-item"><a href="https://juejin.cn/user/149189280672616/posts" target="_blank" rel="noopener noreferrer" class="menu__link">掘金</a></li><li class="menu__list-item"><a href="https://www.itdongdong.com" target="_blank" rel="noopener noreferrer" class="menu__link">博客</a></li><li class="menu__list-item"><a href="https://www.aliyun.com/minisite/goods?userCode=656jmlbm" target="_blank" rel="noopener noreferrer" class="menu__link">阿里云2折</a></li><li class="menu__list-item"><a href="https://github.com/coder-study-room/Front-end-Advanced-Route" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"></a></li></ul></div></div></div></nav><div class="main-wrapper main-docs-wrapper"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>前端进阶导航(2021版)</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">前端精读</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/">1. 精读 js 模块化发展</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/002">2. 精读模态框的最佳实践</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/003">3. 精读前后端渲染之争</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/004">4. 精读AsyncAwait优越之处</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/005">5. 精读民工叔单页数据流方案</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/006">6. 精读JavaScript错误堆栈处理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/007">7. 精读 请停止 css-in-js 的行为</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/008">8. 精读入坑React前没有人会告诉你的事</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/009">9. 精读 Immutable 结构共享</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/010">10. 精读Web Components 的困境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/011">11. 精读前端调试技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/012">12. 精读 React 高阶组件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/013">13. This 带来的困惑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/014">14. 精读架构设计之 DCI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/015">15. 精读 TC39 与 ECMAScript 提案</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/016">16. CSS Animations vs Web Animations API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/017">17. 精读《如何安全地使用 React context》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/018">18. 精读《设计完美的日期选择器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/019">19. 精读《最佳前端面试题》及面试官技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/020">20. 精读 《Nestjs 文档》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/021">21. 精读《Web fonts: when you need them, when you don’t》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/022">22. 精读《V8 引擎特性带来的的 JS 性能变化》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/023">23. 精读《API设计原则》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/024">24. 精读《现代 JavaScript 概览》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/025">25. 精读《null &gt;= 0?》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/026">26. 精读加密媒体扩展（Encrypted Media Extensions，EME）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/027">27. 精读《css-in-js 杀鸡用牛刀》</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/weekly/028">28. 精读《2017前端性能优化备忘录》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/029">29. 精读《JS 中的内存管理》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/030">30. 精读《Javascript 事件循环与异步》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/031">31. 精读《我不再使用高阶组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/032">32. 精读《React Router4.0 进阶概念》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/033">33. 精读《30行js代码创建神经网络》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/034">34. 精读《React 代码整洁之道》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/035">35. 精读《dob - 框架实现》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/036">36. 精读《When You “Git” in Trouble- a Version Control Story》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/037">37. 精读《how we position and what we compare》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/038">38. 精读《dob - 框架使用》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/039">39. 精读《全链路体验浏览器挖矿》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/040">40. 精读《初探 Reason 与 GraphQL》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/041">41. 精读《Ant Design 3.0 背后的故事》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/042">42. 精读《前端数据流哲学》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/043">43. 精读《增强现实与可视化》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/044">44. 精读《Rekit Studio》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/045">45. 精读《React&#x27;s new Context API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/046">46. 精读《react-rxjs》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/047">47. 精读《webpack4.0 升级指南》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/048">48. 精读《Immer.js》源码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/049">49. 精读《Compilers are the New Frameworks》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/050">50. 精读《快速上手构建 ARKit 应用》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/051">51. 精读《Elements of Web Dev》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/052">52. 精读《图解 ES 模块》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/053">53. 精读《插件化思维》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/054">54. 精读《在浏览器运行 serverRender》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/055">55. 精读《async await 是把双刃剑》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/056">56. 精读《重新思考 Redux》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/057">57. 精读《现代 js 框架存在的根本原因》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/058">58. 精读《Typescript2.0 - 2.9》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/059">59. 精读《如何利用 Nodejs 监听文件夹》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/060">60. 精读《如何在 nodejs 使用环境变量》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/061">61. 精读《React 八种条件渲染》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/062">62. 精读《JS 引擎基础之 Shapes and Inline Caches》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/063">63. 精读《React 的多态性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/064">64. 精读《手写 SQL 编译器 - 词法分析》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/065">65. 精读《手写 SQL 编译器 - 文法介绍》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/066">66. 精读《手写 SQL 编译器 - 语法分析》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/067">67. 精读《手写 SQL 编译器 - 回溯》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/068">68. 精读衡量用户体验</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/069">69. 精读《SQL vs Flux》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/070">70. 精读《手写 SQL 编译器 - 语法树》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/071">71. 精读《手写 SQL 编译器 - 错误提示》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/072">72. 精读《REST, GraphQL, Webhooks, &amp; gRPC 如何选型》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/073">73. 精读《sqorn 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/074">74. 精读《12 个评估 JS 库你需要关心的事》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/075">75. 精读《Epitath 源码 - renderProps 新用法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/076">76. 精读《谈谈 Web Workers》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/077">77. 精读《用 Reduce 实现 Promise 串行执行》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/078">78. 精读《手写 SQL 编译器 - 性能优化之缓存》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/079">79. 精读《React Hooks》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/080">80. 精读《怎么用 React Hooks 造轮子》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/081">81. 精读《使用 CSS 属性选择器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/082">82. 精读《Htm - Hyperscript 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/083">83. 精读《React16 新特性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/084">84. 精读《Typescript 3.2 新特性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/085">85. 精读《手写 SQL 编译器 - 智能提示》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/086">86. 精读《国际化布局 - Logical Properties》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/087">87. 精读《setState 做了什么》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/088">88. 精读《Caches API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/089">89. 精读《如何编译前端项目与组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/090">90. 精读《极客公园 2019》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/091">91. 精读《正则 ES2018》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/092">92. 精读《React PowerPlug 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/093">93. 精读《syntax-parser 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/094">94. 精读《Serverless 给前端带来了什么》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/095">95. 精读《Function VS Class 组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/096">96. 精读《useEffect 完全指南》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/097">97. 精读《编写有弹性的组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/098">98. 精读《react-easy-state 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/099">99. 精读《Scheduling in React》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/100">100. 精读《V8 引擎 Lazy Parsing》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/101">101. 精读《持续集成 vs 持续交付 vs 持续部署》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/102">102. 精读《Monorepo 的优势》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/103">103. 精读《为什么专家不再关心技术细节》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/104">104. 精读《Function Component 入门》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/105">105. 精读《What&#x27;s new in javascript》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/106">106. 精读《数据之上·智慧之光 - 2018》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/107">107. 精读《Optional chaining》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/108">108. 精读《智能商业》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/109">109. 精读《Vue3.0 Function API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/110">110. 精读《Inject Instance 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/111">111. 精读《前端未来展望》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/112">112. 精读《源码学习》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/113">113. 精读《Nodejs V12》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/114">114. 精读《谁在世界中心》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/115">115.精读《Tableau 入门》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/116">116. 精读《刷新》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/117">117. 精读《Tableau 探索式模型》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/118">118. 精读《使用 css 变量生成颜色主题》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/119">119. 精读《前端深水区》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/120">120. 精读《React Hooks 最佳实践》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/121">121. 精读《前端与 BI》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/122">122. 精读《robot 源码 - 有限状态机》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/123">123. 精读《用 Babel 创造自定义 JS 语法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/124">124. 精读《用 css grid 重新思考布局》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/125">125. 精读《深度学习 - 函数式之美》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/126">126. 精读《Nuxtjs》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/127">127. 精读《React Conf 2019 - Day1》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/128">128. 精读《Hooks 取数 - swr 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/129">129. 精读《React Conf 2019 - Day2》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/130">130. 精读《unstated 与 unstated-next 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/131">131. 精读《从 0 到 1》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/132">132. 精读《正交的 React 组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/133">133. 精读《寻找框架设计的平衡点》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/134">134. 精读《我在阿里数据中台大前端》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/135">135. 精读《极客公园 IFX - 上》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/136">136. 精读《极客公园 IFX - 下》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/137">137. 精读《当我在分享的时候，我在做什么？》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/138">138. 精读《精通 console.log》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/139">139. 精读《手写 JSON Parser》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/140">140. 精读《结合 React 使用原生 Drag Drop API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/141">141. 精读《useRef 与 createRef 的区别》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/142">142. 精读《如何做好 CodeReview》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/143">143. 精读《Suspense 改变开发方式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/144">144. 精读《Webpack5 新特性 - 模块联邦》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/145">145. 精读《React Router v6》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/146">146. 精读《React Hooks 数据流》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/147">147. 精读《@types react 值得注意的 TS 技巧》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/148">148. 精读《React Error Boundaries》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/149">149. 精读《React 性能调试》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/150">150. 精读《Deno 1.0 你需要了解的》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/151">151. 精读《@umijs use-request》源码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/152">152. 精读《recoil》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/153">153. 精读《snowpack》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/154">154. 精读《用 React 做按需渲染》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/155">155. 精读《use-what-changed 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/156">156. 精读《react-intersection-observer 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/157">157. 精读《如何比较 Object 对象》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/158">158. 精读《Typescript 4》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/159">159. 精读《对低代码搭建的理解》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/160">160. 精读《函数缓存》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/161">161. 精读《可视化搭建思考 - 富文本搭建》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/162">162. 精读《Tasks, microtasks, queues and schedules》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/163">163. 精读《Spring 概念》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/164">164. 精读《数据搭建引擎 bi-designer API-设计器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/165">165. 精读《数据搭建引擎 bi-designer API-组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/166">166. 精读《BI 搭建 - 筛选条件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/167">167. 精读《设计模式 - Abstract Factory 抽象工厂》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/168">168. 精读《设计模式 - Builder 生成器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/169">169. 精读《设计模式 - Factory Method 工厂方法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/170">170. 精读《设计模式 - Prototype 原型模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/171">171. 精读《设计模式 - Singleton 单例模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/172">172. 精读《设计模式 - Adapter 适配器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/173">173. 精读《设计模式 - Bridge 桥接模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/174">174. 精读《设计模式 - Composite 组合模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/175">175. 精读《设计模式 - Decorator 装饰器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/176">176. 精读《设计模式 - Facade 外观模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/177">177. 精读《设计模式 - Flyweight 享元模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/178">178. 精读《设计模式 - Proxy 代理模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/179">179. 精读《设计模式 - Chain of Responsibility 职责链模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/180">180. 精读《设计模式 - Command 命令模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/181">181. 精读《设计模式 - Interpreter 解释器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/182">182. 精读《设计模式 - Iterator 迭代器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/183">183. 精读《设计模式 - Mediator 中介者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/184">184. 精读《设计模式 - Memoto 备忘录模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/185">185. 精读《设计模式 - Observer 观察者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/186">186. 精读《设计模式 - State 状态模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/187">187. 精读《设计模式 - Strategy 策略模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/188">188. 精读《设计模式 - Template Method 模版模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/189">189. 精读《设计模式 - Visitor 访问者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/190">190. 精读《DOM diff 原理详解》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/191">191. 精读《高性能表格》</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><p>本期精读的文章是：<a href="https://www.smashingmagazine.com/2016/12/front-end-performance-checklist-2017-pdf-pages/" target="_blank" rel="noopener noreferrer">Front End Performance Checklist 2017</a></p><p>现在随着 web 应用的复杂性日益增加，其性能优化就会显得尤为必要，同时会给性能指标分析带来新的挑战，因为性能指标之间的差异性非常大，这取决于使用的设备、浏览器、协议、网络类型以及其它能够对性能产生影响的潜在因素(如：CDN、ISP、cache、proxy、firewall、load balancer、server 等)。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="1-引言"></a>1 引言<a class="hash-link" href="#1-引言" title="Direct link to heading">#</a></h2><p><img src="https://cdn.jsdelivr.net/gh/ViktorWong/imgbed/img/20210408181655.png"></p><p>本文提供了解决如何让网站响应更加迅速、访问更加流畅等前端性能优化问题的方法，读者们可以提供一些在实际场景中的性能优化问题以及解决方案，可泛谈优化策略，亦可针对性深入讨论某个优化方法。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="2-内容概要"></a>2 内容概要<a class="hash-link" href="#2-内容概要" title="Direct link to heading">#</a></h2><p>文中列举了很多不同的性能优化策略、模型或方法，如下：</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="制定目标"></a>制定目标<a class="hash-link" href="#制定目标" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="网站速度快于他人-20"></a>网站速度快于他人 20%<a class="hash-link" href="#网站速度快于他人-20" title="Direct link to heading">#</a></h4><p>根据 <a href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule" target="_blank" rel="noopener noreferrer">psychological research</a> 指出，网站最少在速度上比别人快 20%，才能让用户感觉到比别人的更快。这个速度说的并不是整个页面的加载时间，而是<a href="http://www.websiteoptimization.com/speed/tweak/start-render/" target="_blank" rel="noopener noreferrer">启动渲染时间</a>，<a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint" target="_blank" rel="noopener noreferrer">首次有效渲染时间</a>，<a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive" target="_blank" rel="noopener noreferrer">交互时间</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="控制响应时间在-100ms，控制帧速在-60-帧秒"></a>控制响应时间在 100ms，控制帧速在 60 帧/秒<a class="hash-link" href="#控制响应时间在-100ms，控制帧速在-60-帧秒" title="Direct link to heading">#</a></h4><p><a href="https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/" target="_blank" rel="noopener noreferrer">RAIL performance model</a> 提出的性能优化指标：务必在用户初始操作后的 100ms 内提供反馈。考虑到存在响应时间不足 100ms 的情况，页面最迟要在 50ms 的时候，把控制权交给主线程。</p><p>针对动画，其每一帧都需要在 16ms 内完成，这样才能保证每秒 60 帧（一秒/60=16.6ms），如果可以的话最好能在 10ms 内完成。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="控制首次有效渲染时间在-125s，控制-speedindex-在-1000"></a>控制首次有效渲染时间在 1.25s，控制 SpeedIndex 在 1000<a class="hash-link" href="#控制首次有效渲染时间在-125s，控制-speedindex-在-1000" title="Direct link to heading">#</a></h4><p>控制启动渲染时间在 1s 以内，且速度指数在 1000 以内，对于首次有效渲染时间，最好可以优化到 1.25s 以内。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="环境搭建"></a>环境搭建<a class="hash-link" href="#环境搭建" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="做好构建工具的选型"></a>做好构建工具的选型<a class="hash-link" href="#做好构建工具的选型" title="Direct link to heading">#</a></h4><p>不要过度使用那些酷炫的技术栈，坚持选择适合开发环境的工具，如 Grunt、Gulp、Webpack、PostCSS，或者组合起来的工具。只要这个工具运行的速度够快，而且没有给项目维护带来太大问题，就够了。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="渐进增强"></a>渐进增强<a class="hash-link" href="#渐进增强" title="Direct link to heading">#</a></h4><p>在构建前端结构的时，应始终将<a href="https://www.aaron-gustafson.com/notebook/insert-clickbait-headline-about-progressive-enhancement-here/" target="_blank" rel="noopener noreferrer">渐进增强</a>作为指导原则。首先设计并且构建核心体验，再完善为高性能浏览器设计的高级特性的相关体验。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="前端框架"></a>前端框架<a class="hash-link" href="#前端框架" title="Direct link to heading">#</a></h4><p>最好使用那些支持服务器端渲染的框架，如 Angular，React，Ember 等。所选的框架要保证是被广泛使用并且经过考验的。不同框架对性能有着不同程度的影响，同时对应着不同的优化策略，所以要清楚的了解所选择框架的每个方面。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="amp-或-instant-articles"></a>AMP 或 Instant Articles<a class="hash-link" href="#amp-或-instant-articles" title="Direct link to heading">#</a></h4><ul><li>Google 的 <a href="https://www.ampproject.org/" target="_blank" rel="noopener noreferrer">AMP</a> 技术会提供一套可靠的性能优化框架(基于免费的 CDN 网络)</li><li>Facebook 的 <a href="https://instantarticles.fb.com/" target="_blank" rel="noopener noreferrer">Instant Articles</a> 技术可以在 Facebook 上提升网站的性能。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="合理利用-cdn"></a>合理利用 CDN<a class="hash-link" href="#合理利用-cdn" title="Direct link to heading">#</a></h4><p>根据网站的动态数据量，可以将部分内容给静态网站生成工具生成一个静态版本，将其置于 CDN 上，从而避免数据库的请求，亦可选择基于 CDN 的静态主机平台，通过交互组件丰富页面。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="优化构建"></a>优化构建<a class="hash-link" href="#优化构建" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="确定优先级"></a>确定优先级<a class="hash-link" href="#确定优先级" title="Direct link to heading">#</a></h4><p>将网站的所有文件（js，图片，字体，第三方 script 文件，多媒体内容等）进行分门别类。根据优先级区分基础核心内容，高性能浏览器设计的升级体验，附加内容等。具体细节可参考 <a href="https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/" target="_blank" rel="noopener noreferrer">Improving Smashing Magazine’s Performance</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="使用-cutting-the-mustard-技术"></a>使用 cutting-the-mustard 技术<a class="hash-link" href="#使用-cutting-the-mustard-技术" title="Direct link to heading">#</a></h4><p>使用 <a href="http://responsivenews.co.uk/post/18948466399/cutting-the-mustard" target="_blank" rel="noopener noreferrer">cutting-the-mustard</a> 技术能够实现不同类型的浏览器载入不同类型的资源(传统浏览器载入核心型资源，现代浏览器载入增强型资源)。在载入资源时要严格遵守相应的规则：页面加载时应首先载入 Core 资源，然后在 DomContentLoaded 事件触发时载入 Enhancement 资源，最后在 Load 事件触发时载入 Extras 资源。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="micro-optimization-和-progressive-booting"></a>micro-optimization 和 progressive booting<a class="hash-link" href="#micro-optimization-和-progressive-booting" title="Direct link to heading">#</a></h4><ul><li>使用 <a href="https://twitter.com/lukew/status/665288063195594752" target="_blank" rel="noopener noreferrer">skeleton screens</a> 代替 loading indicator 展示</li><li>使用能够加速 App 初始化渲染的技术，如 <a href="https://medium.com/@richavyas/aha-moments-from-ngconf-2016-part-1-angular-2-0-compile-cycle-6f462f68632e#.8b9afnsub" target="_blank" rel="noopener noreferrer">tree-shaking</a>、<a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener noreferrer">code-splitting</a></li><li>针对<a href="https://www.smashingmagazine.com/2016/03/server-side-rendering-react-node-express" target="_blank" rel="noopener noreferrer">服务端渲染</a>增加<a href="https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/" target="_blank" rel="noopener noreferrer">预编译</a>环节</li><li>使用 <a href="https://github.com/nolanlawson/optimize-js" target="_blank" rel="noopener noreferrer">Optimize.js</a> 来加快初始加载速度，其原理是包装优先级高的调用函数</li><li><a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/" target="_blank" rel="noopener noreferrer">渐进启动</a>，先通过使用服务器端渲染快速完成首次有效渲染，浏览器再通过少量的 JS 代码就可以让交互时间接近于首次有效渲染时间。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="正确设置-http-cache-header"></a>正确设置 HTTP cache header<a class="hash-link" href="#正确设置-http-cache-header" title="Direct link to heading">#</a></h4><p>需要正确设置 expires、cache-control、max-age 以及其它 HTTP 缓存响应头。请使用 Cache-control: immutable，可以参考 <a href="https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers" target="_blank" rel="noopener noreferrer">Heroku’s primer on HTTP caching headers</a>、<a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en" target="_blank" rel="noopener noreferrer">HTTP caching primer</a>以及<a href="https://jakearchibald.com/2016/caching-best-practices/" target="_blank" rel="noopener noreferrer">缓存之最佳实践</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="减少使用第三方库，异步加载-js"></a>减少使用第三方库，异步加载 JS<a class="hash-link" href="#减少使用第三方库，异步加载-js" title="Direct link to heading">#</a></h4><p>想要在不等 js 执行完就开始渲染页面，可以通过在 HTML 的 script 标签上添加 defer 以及 async 属性来实现。减少第三方库和脚本的使用，尤其是社交网站的分享按键和 iframe 嵌入等。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="合理优化图片"></a>合理优化图片<a class="hash-link" href="#合理优化图片" title="Direct link to heading">#</a></h4><ul><li>要实现图片的响应式，应尽可能地使用带有 srcset、sizes 属性的 HTML 标签，如 <code>&lt;picture&gt;</code></li><li>使用 <a href="https://www.smashingmagazine.com/2015/10/webp-images-and-performance/" target="_blank" rel="noopener noreferrer">WebP</a> 格式的图片</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="图片优化进阶"></a>图片优化进阶<a class="hash-link" href="#图片优化进阶" title="Direct link to heading">#</a></h4><ul><li>可以使用<a href="http://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/" target="_blank" rel="noopener noreferrer">渐进式 JPEG 图片</a></li><li>可以使用压缩工具对不同格式的图片进行压缩，如 JPEG 图片用 <a href="https://github.com/mozilla/mozjpeg" target="_blank" rel="noopener noreferrer">mozJPEG</a> 压缩、PNG 图片用 <a href="http://css-ig.net/pingo" target="_blank" rel="noopener noreferrer">Pingo</a> 压缩、GIF 图片用 <a href="https://kornel.ski/lossygif" target="_blank" rel="noopener noreferrer">Lossy GIF</a> 压缩、SVG 图片用 <a href="https://jakearchibald.github.io/svgomg/" target="_blank" rel="noopener noreferrer">SVGOMG</a> 压缩</li><li>可以通过过滤掉不必要的图片细节（通过给图片添加高斯模糊滤镜实现）来减小文件的大小</li><li>可以使用 PhotoShop 导出（质量在 0-10%）的图片用于做背景图</li><li>可以使用<a href="http://csswizardry.com/2016/10/improving-perceived-performance-with-multiple-background-images/" target="_blank" rel="noopener noreferrer">多张背景图的技巧</a>来提高对图片性能感知的能力</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="优化-web-字体"></a>优化 web 字体<a class="hash-link" href="#优化-web-字体" title="Direct link to heading">#</a></h4><ul><li>如果使用开源字体，可以使用字体库中的子集或自己归类的子集来压缩文件大小</li><li>浏览器对 WOFF2 的支持度较高，当浏览器不支持 WOFF2 时，可以将 WOFF、OTF 作为备用</li><li>可以从 <a href="https://www.zachleat.com/web/comprehensive-webfonts/" target="_blank" rel="noopener noreferrer">Comprehensive Guide to Font-Loading Strategies</a> 中选择一些针对字体优化的策略</li><li>可以使用 service worker 来达到字体缓存持久化</li><li><a href="https://pixelambacht.nl/2016/font-awesome-fixed/" target="_blank" rel="noopener noreferrer">关于如何快速入门字体优化的教程</a></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="快速推送-critical-css-文件"></a>快速推送 critical CSS 文件<a class="hash-link" href="#快速推送-critical-css-文件" title="Direct link to heading">#</a></h4><p>为了保证能够让浏览器快速渲染，会将所有用于首屏渲染的 CSS 文件整合成一个文件（即 <a href="https://www.smashingmagazine.com/2015/08/understanding-critical-css/" target="_blank" rel="noopener noreferrer">critical CSS</a>），以 <code>&lt;style&gt;</code> 的行内形式内嵌到 <code>&lt;head&gt;</code>，这样可以减少 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=en" target="_blank" rel="noopener noreferrer">critical 渲染路径</a>。由于 HTTP 数据包大小的限制，因此 critical CSS 文件大小不能超过 14KB。</p><p>HTTP/2 协议可以让 critical CSS 用单个 CSS 文件存储，通过服务器推送 CSS 文件的传输方式来减少 HTML 文件数据量，由于存在高速缓存问题，因此需要建立<a href="https://css-tricks.com/cache-aware-server-push/" target="_blank" rel="noopener noreferrer">带有缓存的 HTTP/2 服务器传输机制</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="tree-shaking-和-code-splitting-机制减轻负载"></a>tree-shaking 和 code-splitting 机制减轻负载<a class="hash-link" href="#tree-shaking-和-code-splitting-机制减轻负载" title="Direct link to heading">#</a></h4><ul><li><a href="https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf" target="_blank" rel="noopener noreferrer">Tree-shaking</a> 机制能够帮助清理生产环境中的冗余代码。可以通过 <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html" target="_blank" rel="noopener noreferrer">Webpack2 Tree-Shaking</a> 机制来清理冗余的 exports 代码或者使用 <a href="https://github.com/giakki/uncss" target="_blank" rel="noopener noreferrer">UnCSS</a>、<a href="https://github.com/geuis/helium-css" target="_blank" rel="noopener noreferrer">Helium</a> 工具来清理冗余的 CSS 代码</li><li><a href="https://webpack.github.io/docs/code-splitting.html" target="_blank" rel="noopener noreferrer">code splitting</a> 机制是 Webpack 的另一个特性，它能够将构建的代码分成多个 chunk，并且对 chunk 按需载入。只要在代码中定义了分离点（split point），Webpack 便会处理好相关的输出文件，不仅能够较少文件数据量，而且还能对代码做到按需载入。</li><li>用 <a href="http://rollupjs.org/" target="_blank" rel="noopener noreferrer">Rollup</a> 来 export 代码也能够取得不错的效果</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="提升渲染性能"></a>提升渲染性能<a class="hash-link" href="#提升渲染性能" title="Direct link to heading">#</a></h4><p>可以通过使用 <a href="http://caniuse.com/#search=contain" target="_blank" rel="noopener noreferrer">css containment</a> 属性的方式来达到隔离性能开销大的组件，限制浏览器样式的范围，限制作用在 canvas 以外的布局和绘制工作中，限制用在第三方工具上，以确保页面滚动和出现动画效果时没有延迟。推荐使用 CSS 属性 will-change，该属性能够在元素的属性改变之前通知浏览器。</p><p>需要衡量浏览器在处于<a href="https://aerotwist.com/blog/my-performance-audit-workflow/#runtime-performance" target="_blank" rel="noopener noreferrer">运行时渲染模式下的性能</a>，可以参考<a href="https://www.udacity.com/course/browser-rendering-optimization--ud860" target="_blank" rel="noopener noreferrer">浏览器渲染优化</a>、<a href="https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/" target="_blank" rel="noopener noreferrer">如何正确的使用 GPU</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="优化网络环境，加快网络传输"></a>优化网络环境，加快网络传输<a class="hash-link" href="#优化网络环境，加快网络传输" title="Direct link to heading">#</a></h4><ul><li>使用 skeleton screen 或者使用懒加载的方式载入字体或者开销大的组件，如视频、iframe、图片等</li><li><a href="http://caniuse.com/#search=dns-prefetch" target="_blank" rel="noopener noreferrer">dns-prefetch</a>，能够让浏览器在后台进程执行一次 DNS 查询</li><li><a href="http://www.caniuse.com/#search=preconnect" target="_blank" rel="noopener noreferrer">preconnect</a>，能够让浏览器在后台进程发起一次握手（DNS，TCP，TLS）</li><li><a href="http://caniuse.com/#search=prefetch" target="_blank" rel="noopener noreferrer">prefetch</a>，能够让浏览器发起对资源的请求</li><li><a href="http://caniuse.com/#search=prerender" target="_blank" rel="noopener noreferrer">prerender</a>，能够让浏览器在后台进程渲染出特定的页面</li><li><a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="noopener noreferrer">preload</a>，在不执行资源的前提下，预先拿到该资源</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="http2"></a>HTTP/2<a class="hash-link" href="#http2" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="为-http2-环境的搭建做好准备"></a>为 HTTP/2 环境的搭建做好准备<a class="hash-link" href="#为-http2-环境的搭建做好准备" title="Direct link to heading">#</a></h4><p>从目前来看，浏览器对 HTTP/2 支持度还不错，使用 HTTP/2 后，就可以利用 service worker 以及 HTTP/2 的服务器推送功能来获取更显著的性能提升。</p><p>在项目进行 HTTPS 改造时，需要评估 HTTP/1.1 项目的用户基数，需要针对这类用户构建并发送符合 HTTP2 规范的报头。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="正确部署-http2"></a>正确部署 HTTP/2<a class="hash-link" href="#正确部署-http2" title="Direct link to heading">#</a></h4><p>需要在载入大模块以及并行载入小模块之间找到一个平衡点。</p><ul><li>将所有视图都分散到小模块中，然后在项目构建的过程中完成对小模块的压缩，最后通过 <a href="https://rmurphey.com/blog/2015/11/25/building-for-http2" target="_blank" rel="noopener noreferrer">scount approach</a> 以及异步的方式来分别实现对模块的引用及载入，对一个文件将不再需要重新下载整个样式清单或 js 文件</li><li><a href="http://engineering.khanacademy.org/posts/js-packaging-http2.htm" target="_blank" rel="noopener noreferrer">HTTP/2 环境下打包 js 文件时存在问题</a>，由于向浏览器发送很多 js 小文件的过程中会存在很多问题。 首先，文件压缩的优势被破坏。在压缩大文件的过程中，借助 dictionary reuse 可以达到优化性能的目的，然而单个小文件就不能。其次，浏览器不能针对一些工作流进行优化</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="确保服务器的安全性"></a>确保服务器的安全性<a class="hash-link" href="#确保服务器的安全性" title="Direct link to heading">#</a></h4><p>需要检查是否<a href="https://securityheaders.io/" target="_blank" rel="noopener noreferrer">正确设置 HTTP 请求头部</a>，如 strict-transport-security，<a href="https://www.w3ctech.com/www.smashingmagazine.com/2016/01/eliminating-known-security-vulnerabilities-with-snyk/" target="_blank" rel="noopener noreferrer">使用 Snyk 工具</a>排除已知的漏洞以及<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener noreferrer">使用 SSL Server Test</a> 网站来检查证书是否失效。 尽量保证从外部引入的插件以及 js 脚本的载入是通过 HTTPS 协议的，发起 HTTP 请求同时设置 strict-transport-security 以及 content-security-policy HTTP 请求头。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="服务器和-cdn-是否支持-http2"></a>服务器和 CDN 是否支持 HTTP/2<a class="hash-link" href="#服务器和-cdn-是否支持-http2" title="Direct link to heading">#</a></h4><p>通过 <a href="https://istlsfastyet.com/" target="_blank" rel="noopener noreferrer">Is TLS Fast Yet</a> 来查看不同服务器和 CDN 对 HTTP/2 的兼容情况。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="brotli-或-zopfli-压缩算法"></a>Brotli 或 Zopfli 压缩算法<a class="hash-link" href="#brotli-或-zopfli-压缩算法" title="Direct link to heading">#</a></h4><ul><li><a href="https://samsaffron.com/archive/2016/06/15/the-current-state-of-brotli-compression" target="_blank" rel="noopener noreferrer">Brotli</a>，是 Google 开源的无损数据格式，其压缩效率要远高于 Gzip 和 Deflate</li><li><a href="https://blog.codinghorror.com/zopfli-optimization-literally-free-bandwidth/" target="_blank" rel="noopener noreferrer">Zopfli 压缩算法</a>，能够将数据编码成 Deflate、Gzip、Zlib 数据格式。用 Zopfli 算法压缩过后的文件能够比同样用 Zlib 算法压缩的文件小 3%-8%</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="激活-ocsp-stapling"></a>激活 OCSP stapling<a class="hash-link" href="#激活-ocsp-stapling" title="Direct link to heading">#</a></h4><p>激活服务器的 <a href="https://www.digicert.com/enabling-ocsp-stapling.htm" target="_blank" rel="noopener noreferrer">OCSP stapling</a>，可以减少 TLS 握手所需的时间，加速 TLS 握手过程。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="使用-ipv6"></a>使用 IPv6<a class="hash-link" href="#使用-ipv6" title="Direct link to heading">#</a></h4><p>因为 IPv6 自带 NDP 以及路由优化，能够让网站的载入速度提升 10%-15%。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="hpack-压缩算法"></a>HPACK 压缩算法<a class="hash-link" href="#hpack-压缩算法" title="Direct link to heading">#</a></h4><p>如果网站使用了 HTTP/2，需要检查服务器有没有执行 <a href="https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-http-2/" target="_blank" rel="noopener noreferrer">HPACK</a> 对 HTTP 的响应头进行压缩，来减少不必要的消耗。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="使用-service-worker"></a>使用 service worker<a class="hash-link" href="#使用-service-worker" title="Direct link to heading">#</a></h4><p>如果网站切换到 HTTPS，可以使用 <a href="https://github.com/lyzadanger/pragmatist-service-worker" target="_blank" rel="noopener noreferrer">pragmatist-service-worker</a> 通过 service worker cache 来缓存静态资源、离线页面等，也可以从缓存中拿数据。参考当前<a href="http://caniuse.com/#search=serviceworker" target="_blank" rel="noopener noreferrer">浏览器对 service worker 的支持程度</a>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="测试与监控"></a>测试与监控<a class="hash-link" href="#测试与监控" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="监控警告"></a>监控警告<a class="hash-link" href="#监控警告" title="Direct link to heading">#</a></h4><ul><li>通过 <a href="https://report-uri.io/" target="_blank" rel="noopener noreferrer">Report-URI.io</a> 工具监控混合内容中出现的警告</li><li>通过 <a href="https://github.com/bramus/mixed-content-scan" target="_blank" rel="noopener noreferrer">Mixed Content Scan</a> 工具扫描支持 HTTPS 的网站是否存在混合内容</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="使用-devtools"></a>使用 Devtools<a class="hash-link" href="#使用-devtools" title="Direct link to heading">#</a></h4><p>在 DevTool 中选一个调试工具来对每一个功能进行检查，确保知道如何分析渲染性能和控制台输出、明白如何调试 JS 以及编辑 CSS 样式。参考<a href="https://umaar.github.io/devtools-optimise-your-web-development-workflow-2016/#/" target="_blank" rel="noopener noreferrer">开发者工具的调试技巧</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="使用代理浏览器或过时浏览器测试"></a>使用代理浏览器或过时浏览器测试<a class="hash-link" href="#使用代理浏览器或过时浏览器测试" title="Direct link to heading">#</a></h4><p>完成 Chrome 和 Firefox 的测试是不够的，还需要关注部分区域占比较高的浏览器，如 UC 浏览器、Opera Min 等, 也需要了解一下受关注<a href="https://www.webworldwide.io/" target="_blank" rel="noopener noreferrer">国家的平均网速</a>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="持续监控"></a>持续监控<a class="hash-link" href="#持续监控" title="Direct link to heading">#</a></h4><p>在进行快速、无限制的测试时，最好使用一个个人的 WebPageTest 实例。建立一个能自动预警的性能预算监听。建立自己的用户时间标记从而测量并监测具体商用的数据。使用 SpeedCurve 对性能的变化进行监控，同时利用 New Relic 获取 WebPageTest 没法提供的数据。SpeedTracker，Lighthouse 和 Calibre 都是不错的选择。</p><p>部署私密的 <a href="http://www.webpagetest.org/" target="_blank" rel="noopener noreferrer">WebPageTest</a> 测试环境，有助于快速构建测试用例。针对性能开销大的环节建立自动报警机制，可以使用 <a href="https://speedcurve.com/" target="_blank" rel="noopener noreferrer">SpeedCurve</a> 对性能的变化进行监控，利用 <a href="https://newrelic.com/browser-monitoring" target="_blank" rel="noopener noreferrer">New Relic</a> 获取 WebPageTest 无法提供的数据。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="3-精读"></a>3 精读<a class="hash-link" href="#3-精读" title="Direct link to heading">#</a></h2><p>这一部分会介绍一些上述没有提到的方法，主要是利用 Devtools 工具对性能优化策略或方法进行深入的解读和分析。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="通过-devtools-排查渲染性能问题"></a>通过 Devtools 排查渲染性能问题<a class="hash-link" href="#通过-devtools-排查渲染性能问题" title="Direct link to heading">#</a></h3><p>页面代码被转换成屏幕上显示的像素，这个转换过程可以简单归纳为以下流程，包含五个关键步骤：</p><ul><li>Javascript</li><li>Style</li><li>Layout</li><li>Paint</li><li>Composite</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ViktorWong/imgbed/img/20210408181724.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="timeline"></a>Timeline<a class="hash-link" href="#timeline" title="Direct link to heading">#</a></h4><p>通过 Chrome Timeline 对页面进行 Record，其中绿色波浪线就是页面的帧率。波浪线越高表示帧率越高，反之亦然，帧率区域上边标红一行区域，表示有问题的帧，凡是标红的帧都是存在问题的，排查问题时，需要着重关注帧率低和标红的区域。</p><p>需要逐一排查带红色角标的帧，即是有问题的帧：</p><p><img src="https://cdn.jsdelivr.net/gh/ViktorWong/imgbed/img/20210408181804.png"></p><p>点击选中该帧，可以看到详细的耗时和简单的问题描述：</p><p><img src="https://cdn.jsdelivr.net/gh/ViktorWong/imgbed/img/20210408181824.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="javascript-profiler"></a>Javascript Profiler<a class="hash-link" href="#javascript-profiler" title="Direct link to heading">#</a></h4><p>如果发现运行时间很长的 JavaScript 代码，则可以开启 DevTools 中 JavaScript profiler 选项，可以看到页面中的函数调用链路，就能分析出 JavaScript 代码对于页面渲染性能的影响，从而发现并修复 JavaScript 代码中性能低下的部分。那么如何修复 JavaScript 代码中性能问题呢？</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="使用-requestanimationframe"></a>使用 requestAnimationFrame<a class="hash-link" href="#使用-requestanimationframe" title="Direct link to heading">#</a></h4><p>假设页面上有一个动画效果，想在动画刚刚发生的那一刻运行一段 JavaScript 代码。那么唯一能保证这个运行时机的，就是 requestAnimationFrame。而大部分代码都是用 setTimeout 或 setInterval 来实现页面中的动画效果。这种实现方式的问题是，setTimeout 或 setInterval 中指定的回调函数的执行时机是无法保证的，如果是在帧结束的时候被执行，就意味着可能失去这一帧的信息，也就是发生 jank。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="降低代码复杂度或者使用-web-workers"></a>降低代码复杂度或者使用 Web Workers<a class="hash-link" href="#降低代码复杂度或者使用-web-workers" title="Direct link to heading">#</a></h4><p>JavaScript 代码是运行在浏览器的主线程上的。与此同时，浏览器的主线程还负责样式计算、布局，甚至绘制等的工作。可以想象，如果 JavaScript 代码运行时间过长，就会阻塞主线程上其他的渲染工作，很可能就会导致帧丢失。</p><p>因此，需要规划 JavaScript 代码的运行时机和运行耗时，或在浏览器空闲的时候来来运行更多的 JavaScript 代码。</p><p>也可以把纯计算工作放到 Web Workers 中做，前提是这些计算工作不会涉及 DOM 元素的存取。一般来说，JavaScript 中的数据处理工作，如排序或搜索比较适合这种处理方式。</p><p>如果 JavaScript 代码需要存取 DOM 元素，即必须在主线程上运行，那么可以考虑批处理的方式，把任务细分为若干个小任务，每个小任务耗时很少，各自放在一个 requestAnimationFrame 中回调运行。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="render（style--layout）"></a>Render（Style &amp; Layout）<a class="hash-link" href="#render（style--layout）" title="Direct link to heading">#</a></h3><p>render 部分包括 Recalculate Style 和 Layout，如果发现 render 部分耗时较长，需要分别从这两部分进行分析。如果这一帧，触发了强制 layout，Timeline 会用红色角标标出，这是需要进行优化的地方。</p><p>如果需要具体分析 Recalculate Style，可以选中 Recalculate Style 部分，查看受影响的元素个数、触发 Recalculate Style 函数以及警告提示。</p><p>如果需要分析 Layout，可以选中 Layout 部分，同 Recalculate Style 一样。</p><p><img src="https://cdn.jsdelivr.net/gh/ViktorWong/imgbed/img/20210408181843.png"></p><p>那么如何提升 Render 部分的性能问题呢？</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="降低样式计算和复杂度"></a>降低样式计算和复杂度<a class="hash-link" href="#降低样式计算和复杂度" title="Direct link to heading">#</a></h4><p>添加或移除一个 DOM 元素、修改元素属性和样式类、应用动画效果等操作，都会引起 DOM 结构的改变，从而导致浏览器需要重新计算每个元素的样式、对页面或其一部分重新布局（多数情况下），这就是所谓的样式计算。</p><p>因此需要减少执行样式计算的元素的个数，降低样式选择器的复杂度，使用基于 class 的方式，如以 BEM (Block, Element, Modifier)的方式编写 CSS 代码，能达到最好的样式计算的性能，因为这种方式建议对每个 DOM 元素都只使用一个样式 class。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="避免大规模、复杂的布局"></a>避免大规模、复杂的布局<a class="hash-link" href="#避免大规模、复杂的布局" title="Direct link to heading">#</a></h4><p>布局，就是浏览器计算 DOM 元素的几何信息的过程：元素大小和在页面中的位置。</p><ul><li>尽可能避免触发布局，当修改了元素的样式属性之后，浏览器会将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树。对于 DOM 元素的几何属性的修改，比如 width/height/left/top 等，都需要重新计算布局。通过 DevTools Timeline 可以查看页面性能的分解图，从而判断布局过程是否是页面性能的瓶颈，参考能触发布局、绘制或渲染层合并的 <a href="http://csstriggers.com/" target="_blank" rel="noopener noreferrer">CSS 属性清单</a></li><li>使用 flexbox 替代老的布局模型，在相同数量的元素下 Flexbox 布局，不仅达到了同样的显示效果，而且时间消耗也大大降低，因此需要在对页面布局模型的性能分析的基础之上，来选择一种性能最优的布局方式，而且应该努力避免同时触发所有布局</li><li>避免强制同步布局事件的发生，将一帧画面渲染到屏幕上的处理顺序是执行 JavaScript 脚本、样式计算、布局。但还可以强制浏览器在执行 JavaScript 脚本之前先执行布局过程，这就是所谓的强制同步布局。为了避免触发不必要的布局过程，应该首先批量读取元素样式属性，然后再对样式属性进行写操作，过早地同步执行样式计算和布局是潜在的页面性能的瓶颈之一</li><li>避免快速连续的布局，如果想确保编写的读写操作是安全的，你可以使用 <a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener noreferrer">FastDOM</a>，它能帮你自动完成读写操作的批处理，还能避免意外地触发强制同步布局或快速连续的布局</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="paint"></a>Paint<a class="hash-link" href="#paint" title="Direct link to heading">#</a></h3><p>Paint（绘制）其实是生成元素呈现的像素的过程。在页面的整个被解析、执行、渲染的过程中，Paint 通常来说是代价最高的一步，因此尽量减少 Paint 时间，甚至避免 Paint 的发生，对页面性能的提升有着很重要的作用。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="如何触发-paint"></a>如何触发 Paint<a class="hash-link" href="#如何触发-paint" title="Direct link to heading">#</a></h4><ul><li>触发了 Layout，那么一定会触发 Paint</li><li>改变元素的一些非几何属性，如背景、颜色、阴影等，不会触发 Layout，但是依然会触发 Paint</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="如何定位-paint"></a>如何定位 Paint<a class="hash-link" href="#如何定位-paint" title="Direct link to heading">#</a></h4><p>Timeline 中绿色部分就是 Paint 部分，Summary 会展示绘制的总体情况，包括绘制的元素、元素本身绘制耗时、元素子元素绘制耗时。如果发现绘制的区域超过了本来期望的区域，那么就是需要优化的。更加详细的信息，可以切换至 Paint Profiler，包括了每个具体 Paint 的调用和 Paint 区域截图。当页面发生 Paint 时，如果发现不期望的区域进行了 Paint，那么这里就是可以优化的。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="如何优化-paint"></a>如何优化 Paint<a class="hash-link" href="#如何优化-paint" title="Direct link to heading">#</a></h4><ul><li>提升元素渲染层为合成层，页面的绘制并非是在单层画面里完成的，浏览器的渲染原理，是浏览器将 DOM tree 映射成 GraphicsLayer tree，中间是经过了 RenderObject、RenderLayer 的一系列映射。元素所在的层提升为合成层后可以减少 Repaint</li><li>使用 transform 或 opacity 实现动画，对于独立的合成层应用 transform 和 opacity 是不会触发 Repaint 的，因此尽量对 transform 或 opactiy 应用动画来实现效果</li><li>减少绘制区域，对于不需要重新绘制的区域应尽量避免绘制，已减少绘制区域，比如一个 fix 在页面顶部的固定不变的导航 header，在页面底部某个区域 Repaint 时，整个屏幕包括 fix 的 header 也会被重绘，而对于固定不变的区域，期望其并不会被重绘，因此可以通过之前的方法，将其提升为独立的合成层</li><li>降低绘制复杂度，对于无法避免的 Paint，需要尽可能的减少 Paint 的消耗，有些效果的 Paint 代价十分昂贵，比如绘制一个阴影可能就比绘制一个边框更加耗时，因此开发过程中，需要研究能够实现相同的效果，同时却能达到更小的 Paint 消耗的方法</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="composite"></a>Composite<a class="hash-link" href="#composite" title="Direct link to heading">#</a></h3><p>渲染层合并，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。</p><p>提升为合成层简单说来有以下优点：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理更快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li><li>对于诸如 fixed 的合成层，移动时不会触发 repaint</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="提升动画效果的元素"></a>提升动画效果的元素<a class="hash-link" href="#提升动画效果的元素" title="Direct link to heading">#</a></h4><p>合成层的好处是不会影响到其他元素的绘制，因此，为了减少动画元素对其他元素的影响，从而减少 paint，可以把动画效果中的元素提升为合成层。提升合成层的最好方式是使用 CSS 的 will-change 属性。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="合理管理合成层"></a>合理管理合成层<a class="hash-link" href="#合理管理合成层" title="Direct link to heading">#</a></h4><p>创建一个新的合成层并不是无消耗的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，可能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="防止层爆炸"></a>防止层爆炸<a class="hash-link" href="#防止层爆炸" title="Direct link to heading">#</a></h4><p>同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。因此显式声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="4-总结"></a>4 总结<a class="hash-link" href="#4-总结" title="Direct link to heading">#</a></h2><p>现在随着 web 应用的复杂性日益增加，其性能优化的重要性越来越突出，且性能优化的方法、技巧、工具也越来越丰富和复杂，本文所展示的内容仅仅只是管中窥豹，希望读者们可以在此讨论一些在实际场景中的性能优化问题以及解决方案。</p><blockquote><p>讨论地址是：<a href="http://github.com/dt-fe/weekly/issues/39" target="_blank" rel="noopener noreferrer">精读《2017 前端性能优化备忘录》 · Issue #39 · dt-fe/weekly</a></p></blockquote><blockquote><p>如果你想参与讨论，请<a href="https://github.com/dt-fe/weekly" target="_blank" rel="noopener noreferrer">点击这里</a>，每周都有新的主题，每周五发布。</p></blockquote></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/coder-study-room/Front-end-Advanced-Route/edit/master/weekly/028.精读《2017前端性能优化备忘录》.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-04-08T10:56:46.000Z" class="lastUpdatedDate_1WI_">4/8/2021</time> by <strong>wangweidong</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/weekly/027"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 27. 精读《css-in-js 杀鸡用牛刀》</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/weekly/029"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">29. 精读《JS 中的内存管理》 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-引言" class="table-of-contents__link">1 引言</a></li><li><a href="#2-内容概要" class="table-of-contents__link">2 内容概要</a><ul><li><a href="#制定目标" class="table-of-contents__link">制定目标</a></li><li><a href="#环境搭建" class="table-of-contents__link">环境搭建</a></li><li><a href="#优化构建" class="table-of-contents__link">优化构建</a></li><li><a href="#http2" class="table-of-contents__link">HTTP/2</a></li><li><a href="#测试与监控" class="table-of-contents__link">测试与监控</a></li></ul></li><li><a href="#3-精读" class="table-of-contents__link">3 精读</a><ul><li><a href="#通过-devtools-排查渲染性能问题" class="table-of-contents__link">通过 Devtools 排查渲染性能问题</a></li><li><a href="#render（style--layout）" class="table-of-contents__link">Render（Style &amp; Layout）</a></li><li><a href="#paint" class="table-of-contents__link">Paint</a></li><li><a href="#composite" class="table-of-contents__link">Composite</a></li></ul></li><li><a href="#4-总结" class="table-of-contents__link">4 总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="https://docusaurus.io/img/oss_logo.png" alt="程序员自习室开源" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="https://docusaurus.io/img/oss_logo.png" alt="程序员自习室开源" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></div><div class="footer__copyright">Copyright © 2021 程序员自习室 <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备17131802号</a></div></div></div></footer></div>
<script src="/assets/js/styles.b3f043dc.js"></script>
<script src="/assets/js/runtime~main.b93be3da.js"></script>
<script src="/assets/js/main.fb8f3d2b.js"></script>
<script src="/assets/js/1.46fdb85d.js"></script>
<script src="/assets/js/2.37941b87.js"></script>
<script src="/assets/js/3.8e957956.js"></script>
<script src="/assets/js/1be78505.4595a7b1.js"></script>
<script src="/assets/js/397.3ed54396.js"></script>
<script src="/assets/js/cc953bd4.972fd30a.js"></script>
<script src="/assets/js/17896441.136bed3d.js"></script>
<script src="/assets/js/cbfd5a2e.62d3e796.js"></script>
</body>
</html>