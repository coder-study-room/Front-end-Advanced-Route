<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="前端进阶导航(2021版) Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="前端进阶导航(2021版) Blog Atom Feed"><title data-react-helmet="true">1. 精读 js 模块化发展 🦖 前端进阶导航(2021版)</title><meta data-react-helmet="true" property="og:url" content="https://coder-study-room.github.io/weekly/"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-weekly-current"><meta data-react-helmet="true" property="og:title" content="1. 精读 js 模块化发展 🦖 前端进阶导航(2021版)"><meta data-react-helmet="true" name="description" content="这次是前端精读期刊与大家第一次正式碰面，我们每周会精读并分析若干篇精品好文，试图讨论出结论性观点。没错，我们试图通过观点的碰撞，争做无主观精品好文的意见领袖。"><meta data-react-helmet="true" property="og:description" content="这次是前端精读期刊与大家第一次正式碰面，我们每周会精读并分析若干篇精品好文，试图讨论出结论性观点。没错，我们试图通过观点的碰撞，争做无主观精品好文的意见领袖。"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://coder-study-room.github.io/weekly/"><link data-react-helmet="true" rel="alternate" href="https://coder-study-room.github.io/weekly/" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://coder-study-room.github.io/weekly/" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f86f321e.css">
<link rel="preload" href="/assets/js/styles.b3f043dc.js" as="script">
<link rel="preload" href="/assets/js/runtime~main.41f64a67.js" as="script">
<link rel="preload" href="/assets/js/main.f6fb129f.js" as="script">
<link rel="preload" href="/assets/js/1.46fdb85d.js" as="script">
<link rel="preload" href="/assets/js/2.37941b87.js" as="script">
<link rel="preload" href="/assets/js/3.8e957956.js" as="script">
<link rel="preload" href="/assets/js/1be78505.4595a7b1.js" as="script">
<link rel="preload" href="/assets/js/397.3ed54396.js" as="script">
<link rel="preload" href="/assets/js/cc953bd4.972fd30a.js" as="script">
<link rel="preload" href="/assets/js/17896441.136bed3d.js" as="script">
<link rel="preload" href="/assets/js/fa29c8fd.50e2eb3f.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">前端进阶导航(2021版)</strong></a><a class="navbar__item navbar__link" href="/docs/">进阶</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/weekly/">精读</a><a class="navbar__item navbar__link" href="/interview/">面试</a></div><div class="navbar__items navbar__items--right"><a href="https://juejin.cn/user/149189280672616/posts" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">掘金</a><a href="https://www.itdongdong.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">博客</a><a href="https://www.aliyun.com/minisite/goods?userCode=656jmlbm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">阿里云2折</a><a href="https://github.com/coder-study-room/Front-end-Advanced-Route" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">前端进阶导航(2021版)</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">进阶</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/weekly/">精读</a></li><li class="menu__list-item"><a class="menu__link" href="/interview/">面试</a></li><li class="menu__list-item"><a href="https://juejin.cn/user/149189280672616/posts" target="_blank" rel="noopener noreferrer" class="menu__link">掘金</a></li><li class="menu__list-item"><a href="https://www.itdongdong.com" target="_blank" rel="noopener noreferrer" class="menu__link">博客</a></li><li class="menu__list-item"><a href="https://www.aliyun.com/minisite/goods?userCode=656jmlbm" target="_blank" rel="noopener noreferrer" class="menu__link">阿里云2折</a></li><li class="menu__list-item"><a href="https://github.com/coder-study-room/Front-end-Advanced-Route" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"></a></li></ul></div></div></div></nav><div class="main-wrapper main-docs-wrapper"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>前端进阶导航(2021版)</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">前端精读</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/weekly/">1. 精读 js 模块化发展</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/002">2. 精读模态框的最佳实践</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/003">3. 精读前后端渲染之争</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/004">4. 精读AsyncAwait优越之处</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/005">5. 精读民工叔单页数据流方案</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/006">6. 精读JavaScript错误堆栈处理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/007">7. 精读 请停止 css-in-js 的行为</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/008">8. 精读入坑React前没有人会告诉你的事</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/009">9. 精读 Immutable 结构共享</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/010">10. 精读Web Components 的困境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/011">11. 精读前端调试技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/012">12. 精读 React 高阶组件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/013">13. This 带来的困惑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/014">14. 精读架构设计之 DCI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/015">15. 精读 TC39 与 ECMAScript 提案</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/016">16. CSS Animations vs Web Animations API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/017">17. 精读《如何安全地使用 React context》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/018">18. 精读《设计完美的日期选择器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/019">19. 精读《最佳前端面试题》及面试官技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/020">20. 精读 《Nestjs 文档》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/021">21. 精读《Web fonts: when you need them, when you don’t》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/022">22. 精读《V8 引擎特性带来的的 JS 性能变化》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/023">23. 精读《API设计原则》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/024">24. 精读《现代 JavaScript 概览》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/025">25. 精读《null &gt;= 0?》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/026">26. 精读加密媒体扩展（Encrypted Media Extensions，EME）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/027">27. 精读《css-in-js 杀鸡用牛刀》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/028">28. 精读《2017前端性能优化备忘录》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/029">29. 精读《JS 中的内存管理》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/030">30. 精读《Javascript 事件循环与异步》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/031">31. 精读《我不再使用高阶组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/032">32. 精读《React Router4.0 进阶概念》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/033">33. 精读《30行js代码创建神经网络》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/034">34. 精读《React 代码整洁之道》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/035">35. 精读《dob - 框架实现》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/036">36. 精读《When You “Git” in Trouble- a Version Control Story》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/037">37. 精读《how we position and what we compare》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/038">38. 精读《dob - 框架使用》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/039">39. 精读《全链路体验浏览器挖矿》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/040">40. 精读《初探 Reason 与 GraphQL》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/041">41. 精读《Ant Design 3.0 背后的故事》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/042">42. 精读《前端数据流哲学》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/043">43. 精读《增强现实与可视化》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/044">44. 精读《Rekit Studio》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/045">45. 精读《React&#x27;s new Context API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/046">46. 精读《react-rxjs》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/047">47. 精读《webpack4.0 升级指南》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/048">48. 精读《Immer.js》源码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/049">49. 精读《Compilers are the New Frameworks》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/050">50. 精读《快速上手构建 ARKit 应用》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/051">51. 精读《Elements of Web Dev》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/052">52. 精读《图解 ES 模块》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/053">53. 精读《插件化思维》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/054">54. 精读《在浏览器运行 serverRender》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/055">55. 精读《async await 是把双刃剑》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/056">56. 精读《重新思考 Redux》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/057">57. 精读《现代 js 框架存在的根本原因》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/058">58. 精读《Typescript2.0 - 2.9》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/059">59. 精读《如何利用 Nodejs 监听文件夹》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/060">60. 精读《如何在 nodejs 使用环境变量》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/061">61. 精读《React 八种条件渲染》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/062">62. 精读《JS 引擎基础之 Shapes and Inline Caches》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/063">63. 精读《React 的多态性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/064">64. 精读《手写 SQL 编译器 - 词法分析》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/065">65. 精读《手写 SQL 编译器 - 文法介绍》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/066">66. 精读《手写 SQL 编译器 - 语法分析》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/067">67. 精读《手写 SQL 编译器 - 回溯》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/068">68. 精读衡量用户体验</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/069">69. 精读《SQL vs Flux》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/070">70. 精读《手写 SQL 编译器 - 语法树》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/071">71. 精读《手写 SQL 编译器 - 错误提示》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/072">72. 精读《REST, GraphQL, Webhooks, &amp; gRPC 如何选型》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/073">73. 精读《sqorn 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/074">74. 精读《12 个评估 JS 库你需要关心的事》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/075">75. 精读《Epitath 源码 - renderProps 新用法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/076">76. 精读《谈谈 Web Workers》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/077">77. 精读《用 Reduce 实现 Promise 串行执行》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/078">78. 精读《手写 SQL 编译器 - 性能优化之缓存》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/079">79. 精读《React Hooks》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/080">80. 精读《怎么用 React Hooks 造轮子》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/081">81. 精读《使用 CSS 属性选择器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/082">82. 精读《Htm - Hyperscript 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/083">83. 精读《React16 新特性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/084">84. 精读《Typescript 3.2 新特性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/085">85. 精读《手写 SQL 编译器 - 智能提示》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/086">86. 精读《国际化布局 - Logical Properties》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/087">87. 精读《setState 做了什么》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/088">88. 精读《Caches API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/089">89. 精读《如何编译前端项目与组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/090">90. 精读《极客公园 2019》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/091">91. 精读《正则 ES2018》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/092">92. 精读《React PowerPlug 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/093">93. 精读《syntax-parser 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/094">94. 精读《Serverless 给前端带来了什么》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/095">95. 精读《Function VS Class 组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/096">96. 精读《useEffect 完全指南》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/097">97. 精读《编写有弹性的组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/098">98. 精读《react-easy-state 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/099">99. 精读《Scheduling in React》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/100">100. 精读《V8 引擎 Lazy Parsing》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/101">101. 精读《持续集成 vs 持续交付 vs 持续部署》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/102">102. 精读《Monorepo 的优势》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/103">103. 精读《为什么专家不再关心技术细节》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/104">104. 精读《Function Component 入门》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/105">105. 精读《What&#x27;s new in javascript》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/106">106. 精读《数据之上·智慧之光 - 2018》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/107">107. 精读《Optional chaining》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/108">108. 精读《智能商业》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/109">109. 精读《Vue3.0 Function API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/110">110. 精读《Inject Instance 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/111">111. 精读《前端未来展望》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/112">112. 精读《源码学习》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/113">113. 精读《Nodejs V12》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/114">114. 精读《谁在世界中心》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/115">115.精读《Tableau 入门》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/116">116. 精读《刷新》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/117">117. 精读《Tableau 探索式模型》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/118">118. 精读《使用 css 变量生成颜色主题》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/119">119. 精读《前端深水区》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/120">120. 精读《React Hooks 最佳实践》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/121">121. 精读《前端与 BI》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/122">122. 精读《robot 源码 - 有限状态机》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/123">123. 精读《用 Babel 创造自定义 JS 语法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/124">124. 精读《用 css grid 重新思考布局》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/125">125. 精读《深度学习 - 函数式之美》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/126">126. 精读《Nuxtjs》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/127">127. 精读《React Conf 2019 - Day1》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/128">128. 精读《Hooks 取数 - swr 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/129">129. 精读《React Conf 2019 - Day2》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/130">130. 精读《unstated 与 unstated-next 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/131">131. 精读《从 0 到 1》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/132">132. 精读《正交的 React 组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/133">133. 精读《寻找框架设计的平衡点》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/134">134. 精读《我在阿里数据中台大前端》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/135">135. 精读《极客公园 IFX - 上》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/136">136. 精读《极客公园 IFX - 下》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/137">137. 精读《当我在分享的时候，我在做什么？》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/138">138. 精读《精通 console.log》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/139">139. 精读《手写 JSON Parser》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/140">140. 精读《结合 React 使用原生 Drag Drop API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/141">141. 精读《useRef 与 createRef 的区别》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/142">142. 精读《如何做好 CodeReview》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/143">143. 精读《Suspense 改变开发方式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/144">144. 精读《Webpack5 新特性 - 模块联邦》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/145">145. 精读《React Router v6》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/146">146. 精读《React Hooks 数据流》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/147">147. 精读《@types react 值得注意的 TS 技巧》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/148">148. 精读《React Error Boundaries》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/149">149. 精读《React 性能调试》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/150">150. 精读《Deno 1.0 你需要了解的》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/151">151. 精读《@umijs use-request》源码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/152">152. 精读《recoil》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/153">153. 精读《snowpack》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/154">154. 精读《用 React 做按需渲染》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/155">155. 精读《use-what-changed 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/156">156. 精读《react-intersection-observer 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/157">157. 精读《如何比较 Object 对象》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/158">158. 精读《Typescript 4》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/159">159. 精读《对低代码搭建的理解》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/160">160. 精读《函数缓存》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/161">161. 精读《可视化搭建思考 - 富文本搭建》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/162">162. 精读《Tasks, microtasks, queues and schedules》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/163">163. 精读《Spring 概念》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/164">164. 精读《数据搭建引擎 bi-designer API-设计器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/165">165. 精读《数据搭建引擎 bi-designer API-组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/166">166. 精读《BI 搭建 - 筛选条件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/167">167. 精读《设计模式 - Abstract Factory 抽象工厂》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/168">168. 精读《设计模式 - Builder 生成器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/169">169. 精读《设计模式 - Factory Method 工厂方法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/170">170. 精读《设计模式 - Prototype 原型模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/171">171. 精读《设计模式 - Singleton 单例模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/172">172. 精读《设计模式 - Adapter 适配器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/173">173. 精读《设计模式 - Bridge 桥接模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/174">174. 精读《设计模式 - Composite 组合模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/175">175. 精读《设计模式 - Decorator 装饰器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/176">176. 精读《设计模式 - Facade 外观模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/177">177. 精读《设计模式 - Flyweight 享元模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/178">178. 精读《设计模式 - Proxy 代理模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/179">179. 精读《设计模式 - Chain of Responsibility 职责链模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/180">180. 精读《设计模式 - Command 命令模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/181">181. 精读《设计模式 - Interpreter 解释器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/182">182. 精读《设计模式 - Iterator 迭代器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/183">183. 精读《设计模式 - Mediator 中介者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/184">184. 精读《设计模式 - Memoto 备忘录模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/185">185. 精读《设计模式 - Observer 观察者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/186">186. 精读《设计模式 - State 状态模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/187">187. 精读《设计模式 - Strategy 策略模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/188">188. 精读《设计模式 - Template Method 模版模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/189">189. 精读《设计模式 - Visitor 访问者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/190">190. 精读《DOM diff 原理详解》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/191">191. 精读《高性能表格》</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><p>这次是前端精读期刊与大家第一次正式碰面，我们每周会精读并分析若干篇精品好文，试图讨论出结论性观点。没错，我们试图通过观点的碰撞，争做无主观精品好文的意见领袖。</p><p>我是这一期的主持人 —— <a href="https://github.com/ascoders" target="_blank" rel="noopener noreferrer">黄子毅</a></p><p>本期精读的文章是：<a href="https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity" target="_blank" rel="noopener noreferrer">evolutionOfJsModularity</a>。</p><p>懒得看文章？没关系，稍后会附上文章内容概述，同时，更希望能通过阅读这一期的精读，穿插着深入阅读原文。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="1-引言"></a>1 引言<a class="hash-link" href="#1-引言" title="Direct link to heading">#</a></h2><p><img src="https://cdn.jsdelivr.net/gh/ViktorWong/imgbed/img/20210408174757.png"></p><blockquote><p>如今，Javascript 模块化规范非常方便、自然，但这个新规范仅执行了 2 年，就在 4 年前，js 的模块化还停留在运行时支持，10 年前，通过后端模版定义、注释定义模块依赖。对经历过来的人来说，历史的模块化方式还停留在脑海中，反而新上手的同学会更快接受现代的模块化规范。</p></blockquote><p>但为什么要了解 Javascript 模块化发展的历史呢？因为凡事都有两面性，了解 Javascript 模块化规范，有利于我们思考出更好的模块化方案，纵观历史，从 1999 年开始，模块化方案最多维持两年，就出现了新的替代方案，比原有的模块化更清晰、强壮，我们不能被现代模块化方式限制住思维，因为现在的 ES2015 模块化方案距离发布也仅仅过了两年。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="2-内容概要"></a>2 内容概要<a class="hash-link" href="#2-内容概要" title="Direct link to heading">#</a></h2><p><strong>直接定义依赖 (1999)</strong>: 由于当时 js 文件非常简单，模块化方式非常简单粗暴 —— 通过全局方法定义、引用模块。这种定义方式与现在的 commonjs 非常神似，区别是 commonjs 以文件作为模块，而这种方法可以在任何文件中定义模块，模块不与文件关联。</p><p><strong>闭包模块化模式 (2003)</strong>: 用闭包方式解决了变量污染问题，闭包内返回模块对象，只需对外暴露一个全局变量。</p><p><strong>模版依赖定义 (2006)</strong>: 这时候开始流行后端模版语法，通过后端语法聚合 js 文件，从而实现依赖加载，说实话，现在 go 语言等模版语法也很流行这种方式，写后端代码的时候不觉得，回头看看，还是挂在可维护性上。</p><p><strong>注释依赖定义 (2006)</strong>: 几乎和模版依赖定义同时出现，与 1999 年方案不同的，不仅仅是模块定义方式，而是终于以文件为单位定义模块了，通过 <a href="https://github.com/bevacqua/lazyjs" target="_blank" rel="noopener noreferrer">lazyjs</a> 加载文件，同时读取文件注释，继续递归加载剩下的文件。</p><p><strong>外部依赖定义 (2007)</strong>: 这种定义方式在 cocos2d-js 开发中普遍使用，其核心思想是将依赖抽出单独文件定义，这种方式不利于项目管理，毕竟依赖抽到代码之外，我是不是得两头找呢？所以才有通过 webpack 打包为一个文件的方式暴力替换为 commonjs 的方式出现。</p><p><strong>Sandbox 模式 (2009)</strong>: 这种模块化方式很简单，暴力，将所有模块塞到一个 <code>sandbox</code> 变量中，硬伤是无法解决命名冲突问题，毕竟都塞到一个 <code>sandbox</code> 对象里，而 <code>Sandbox</code> 对象也需要定义在全局，存在被覆盖的风险。模块化需要保证全局变量尽量干净，目前为止的模块化方案都没有很好的做到这一点。</p><p><strong>依赖注入 (2009)</strong>: 就是大家熟知的 angular1.0，依赖注入的思想现在已广泛运用在 react、vue 等流行框架中。但依赖注入和解决模块化问题还差得远。</p><p><strong>CommonJS (2009)</strong>: 真正解决模块化问题，从 node 端逐渐发力到前端，前端需要使用构建工具模拟。</p><p><strong>Amd (2009)</strong>: 都是同一时期的产物，这个方案主要解决前端动态加载依赖，相比 commonJs，体积更小，按需加载。</p><p><strong>Umd (2011)</strong>: 兼容了 CommonJS 与 Amd，其核心思想是，如果在 commonjs 环境（存在 <code>module.exports</code>，不存在 <code>define</code>），将函数执行结果交给 <code>module.exports</code> 实现 Commonjs，否则用 Amd 环境的 <code>define</code>，实现 Amd。</p><p><strong>Labeled Modules (2012)</strong>: 和 Commonjs 很像了，没什么硬伤，但生不逢时，碰上 Commonjs 与 Amd，那只有被人遗忘的份了。</p><p><strong>YModules (2013)</strong>: 既然都出了 Commonjs Amd，文章还列出了此方案，一定有其独到之处。其核心思想在于使用 <code>provide</code> 取代 <code>return</code>，可以控制模块结束时机，处理异步结果；拿到第二个参数 <code>module</code>，修改其他模块的定义（虽然很有拓展性，但用在项目里是个搅屎棍）。</p><p><strong>ES2015 Modules (2015)</strong>: 就是我们现在的模块化方案，还没有被浏览器实现，大部分项目已通过 <code>babel</code> 或 <code>typescript</code> 提前体验。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="3-精读"></a>3 精读<a class="hash-link" href="#3-精读" title="Direct link to heading">#</a></h2><p>本次提出独到观点的同学有：<a href="https://github.com/arcthur" target="_blank" rel="noopener noreferrer">流形</a>，<a href="https://github.com/ascoders" target="_blank" rel="noopener noreferrer">黄子毅</a>，<a href="https://github.com/javie007" target="_blank" rel="noopener noreferrer">苏里约</a>，<a href="https://github.com/camsong" target="_blank" rel="noopener noreferrer">camsong</a>，<a href="https://github.com/jasonslyvia" target="_blank" rel="noopener noreferrer">杨森</a>，<a href="https://github.com/BlackGanglion" target="_blank" rel="noopener noreferrer">淡苍</a>，<a href="https://github.com/fanhc019" target="_blank" rel="noopener noreferrer">留影</a>，精读由此归纳。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="从语言层面到文件层面的模块化"></a>从语言层面到文件层面的模块化<a class="hash-link" href="#从语言层面到文件层面的模块化" title="Direct link to heading">#</a></h3><blockquote><p>从 1999 年开始，模块化探索都是基于语言层面的优化，真正的革命从 2009 年 CommonJS 的引入开始，前端开始大量使用预编译。</p></blockquote><p>这篇文章所提供的模块化历史的方案都是逻辑模块化，<strong>从 CommonJS 方案开始前端把服务端的解决方案搬过来之后，算是看到标准物理与逻辑统一的模块化</strong>。但之后前端工程不得不引入模块化构建这一步。正是这一步给前端开发无疑带来了诸多的不便，尤其是现在我们开发过程中经常为了优化这个工具带了很多额外的成本。</p><p>从 CommonJS 之前其实都只是封装，并没有一套模块化规范，这个就有些像类与包的概念。我在 10 年左右用的最多的还是 YUI2，YUI2 是用 namespace 来做模块化的，但有很多问题没有解决，比如多版本共存，因此后来 YUI3 出来了。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly javascript"><div tabindex="0" class="prism-code language-javascript codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token constant" style="color:rgb(100, 102, 149)">YUI</span><span class="token punctuation" style="color:rgb(36, 41, 46)">(</span><span class="token punctuation" style="color:rgb(36, 41, 46)">)</span><span class="token punctuation" style="color:rgb(36, 41, 46)">.</span><span class="token method function property-access" style="color:rgb(111, 66, 193)">use</span><span class="token punctuation" style="color:rgb(36, 41, 46)">(</span><span class="token string">&#x27;node&#x27;</span><span class="token punctuation" style="color:rgb(36, 41, 46)">,</span><span class="token plain"> </span><span class="token string">&#x27;event&#x27;</span><span class="token punctuation" style="color:rgb(36, 41, 46)">,</span><span class="token plain"> </span><span class="token keyword" style="color:#e3116c">function</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(36, 41, 46)">(</span><span class="token parameter">Y</span><span class="token punctuation" style="color:rgb(36, 41, 46)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(36, 41, 46)">{</span><span class="token plain"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    </span><span class="token comment" style="color:rgb(106, 153, 85)">// The Node and Event modules are loaded and ready to use.</span><span class="token plain"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    </span><span class="token comment" style="color:rgb(106, 153, 85)">// Your code goes here!</span><span class="token plain"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain"></span><span class="token punctuation" style="color:rgb(36, 41, 46)">}</span><span class="token punctuation" style="color:rgb(36, 41, 46)">)</span><span class="token punctuation" style="color:rgb(36, 41, 46)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>YUI3 的 sandbox 像极了差不多同时出现的 AMD 规范，但早期 yahoo 在前端圈的影响力还是很大的，而 requirejs 到 2011 年才诞生，因此圈子不是用着 YUI 要不就自己封装一套 sandbox，内部使用 jQuery。</p><p>为什么模块化方案这么晚才成型，可能早期应用的复杂度都在后端，前端都是非常简单逻辑。后来 Ajax 火了之后，web app 概念的开始流行，前端的复杂度也呈指数级上涨，到今天几乎和后端接近一个量级。<strong>工程发展到一定阶段，要出现的必然会出现。</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="前端三剑客的模块化展望"></a>前端三剑客的模块化展望<a class="hash-link" href="#前端三剑客的模块化展望" title="Direct link to heading">#</a></h3><blockquote><p>从 js 模块化发展史，我们还看到了 css html 模块化方面的严重落后，如今依赖编译工具的模块化增强在未来会被标准所替代。</p></blockquote><p>原生支持的模块化，<strong>解决 html 与 css 模块化问题正是以后的方向。</strong></p><p>再回到 JS 模块化这个主题，开头也说到是为了构建 scope，实则提供了业务规范标准的输入输出的方式。但文章中的 JS 的模块化还不等于前端工程的模块化，Web 界面是由 HTML、CSS 和 JS 三种语言实现，不论是 CommonJS 还是 AMD 包括之后的方案都无法解决 CSS 与 HTML 模块化的问题。</p><p>对于 CSS 本身它就是 global scope，因此开发样式可以说是喜忧参半。近几年也涌现把 HTML、CSS 和 JS 合并作模块化的方案，其中 react/css-modules 和 vue 都为人熟知。当然，这一点还是非常依赖于 webpack/rollup 等构建工具，让我们意识到在 browser 端还有很多本质的问题需要推进。</p><p>对于 css 模块化，目前不依赖预编译的方式是 <code>styled-component</code>，通过 js 动态创建 class。而目前 css 也引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener noreferrer">与 js 通信的机制 与 原生变量支持</a>。未来 css 模块化也很可能是运行时的，所以目前比较看好 <code>styled-component</code> 的方向。</p><p>对于 html 模块化，小尤最近爆出与 chrome 小组调研 html Modules，如果 html 得到了浏览器，编辑器的模块化支持，未来可能会取代 jsx 成为最强大的模块化、模板语言。</p><p>对于 js 模块化，最近出现的 <code>&lt;script type=&quot;module&quot;&gt;</code> 方式，虽然还没有得到浏览器原生支持，但也是我比较看好的未来趋势，这样就连 webpack 的拆包都不需要了，直接把源代码传到服务器，配合 http2.0 完美抛开预编译的枷锁。</p><p>上述三中方案都不依赖预编译，分别实现了 html、css、js 模块化，相信这就是未来。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="模块化标准推进速度仍然缓慢"></a>模块化标准推进速度仍然缓慢<a class="hash-link" href="#模块化标准推进速度仍然缓慢" title="Direct link to heading">#</a></h3><blockquote><p>2015 年提出的标准，在 17 年依然没有得到实现，即便在 nodejs 端。</p></blockquote><p>这几年 TC39 对语言终于重视起来了，慢慢有动作了，但针对模块标准制定的速度，与落实都非常缓慢，与 javascript 越来越流行的趋势逐渐脱节。nodejs 至今也没有实现 ES2015 模块化规范，所有 jser 都处在构建工具的阴影下。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="http-20-对-js-模块化的推动"></a>Http 2.0 对 js 模块化的推动<a class="hash-link" href="#http-20-对-js-模块化的推动" title="Direct link to heading">#</a></h3><blockquote><p>js 模块化定义的再美好，浏览器端的支持粒度永远是瓶颈，http 2.0 正是考虑到了这个因素，大力支持了 ES 2015 模块化规范。</p></blockquote><p>幸运的是，模块化构建将来可能不再需要。随着 HTTP/2 流行起来，请求和响应可以并行，一次连接允许多个请求，对于前端来说宣告不再需要在开发和上线时再做编译这个动作。</p><p>几年前，模块化几乎是每个流行库必造的轮子（YUI、Dojo、Angular），大牛们自己爽的同时其实造成了社区的分裂，很难积累。有了 ES2015 Modules 之后，JS 开发者终于可以像 Java 开始者十年前一样使用一致的方式愉快的互相引用模块。</p><p>不过 ES2015 Modules 也只是解决了开发的问题，由于浏览器的特殊性，还是要经过繁琐打包的过程，等 Import，Export 和 HTTP 2.0 被主流浏览器支持，那时候才是彻底的模块化。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="http-20-后就不需要构建工具了吗？"></a>Http 2.0 后就不需要构建工具了吗？<a class="hash-link" href="#http-20-后就不需要构建工具了吗？" title="Direct link to heading">#</a></h3><blockquote><p>看到大家基本都提到了 HTTP/2，对这项技术解决前端模块化及资源打包等工程问题抱有非常大的期待。很多人也认为 HTTP/2 普及后，基本就没有 Webpack 什么事情了。</p></blockquote><p>不过 Webpack 作者 @sokra 在他的文章 <a href="https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.zdo4juvgo" target="_blank" rel="noopener noreferrer">webpack &amp; HTTP/2</a> 里提到了一个新的 Webpack 插件 <code>AggressiveSplittingPlugin</code>。简单的说，这款插件就是为了充分利用 HTTP/2 的文件缓存能力，将你的业务代码自动拆分成若干个数十 KB 的小文件。后续若其中任意一个文件发生变化，可以保证其他的小 chunk 不需要重新下载。</p><p>可见，<strong>即使不断的有新技术出现，也依然需要配套的工具来将前端工程问题解决方案推向极致。</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="模块化是大型项目的银弹吗？"></a>模块化是大型项目的银弹吗？<a class="hash-link" href="#模块化是大型项目的银弹吗？" title="Direct link to heading">#</a></h3><blockquote><p>只要遵循了最新模块化规范，就可以使项目具有最好的可维护性吗？ Js 模块化的目的是支持前端日益上升的复杂度，但绝不是唯一的解决方案。</p></blockquote><p>分析下 JavaScript 为什么没有模块化，为什么又需要模块化：这个 95 年被设计出来的时候，语言的开发者根本没有想到它会如此的大放异彩，也没有将它设计成一种模块化语言。按照文中的说法，99 年也就是 4 年后开始出现了模块化的需求。如果只有几行代码用模块化是扯，初始的 web 开发业务逻辑都写在 server 端，js 的作用小之又小。而现在 spa 都出现了，几乎所有的渲染逻辑都在前端，如果还是没有模块化的组织，开发过程会越来越难，维护也是更痛苦。</p><p>文中已经详细说明了模块化的发展和优劣，这里不准备做过多的讨论。我想说的是，<strong>在模块化之后还有一个模块间耦合的问题，如果模块间耦合度大也会降低代码的可重用性或者说复用性</strong>。所以也出现了降低耦合的观察者模式或者发布/订阅模式。这对于提升代码重用，复用性和避免单点故障等都很重要。说到这里，还想顺便提一下最近流行起来的响应式编程（RxJS），响应式编程中有一个很核心的概念就是 observable，也就是 Rx 中的流（stream）。它可以被 subscribe，其实也就是观察者设计模式。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="补充阅读"></a>补充阅读<a class="hash-link" href="#补充阅读" title="Direct link to heading">#</a></h3><ul><li><a href="https://huangxuan.me/2015/07/09/js-module-7day/" target="_blank" rel="noopener noreferrer">JavaScript 模块化七日谈</a></li><li><a href="https://yuguo.us/weblog/javascript-module-development-history/" target="_blank" rel="noopener noreferrer">JavaScript 模块化编程简史（2009-2016）</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><p>未来前端复杂度不断增加已成定论，随着后端成熟，自然会将焦点转移到前端领域，而且服务化、用户体验越来越重要，前端体验早不是当初能看就行，任何网页的异常、视觉的差异，或文案的模糊，都会导致用户流失，支付中断。前端对公司营收的影响，渐渐与后端服务宕机同等严重，所以前端会越来越重，异常监控，性能检测，工具链，可视化等等都是这几年大家逐渐重视起来的。</p><p>我们早已不能将 javascript 早期玩具性质的模块化方案用于现代越来越重要的系统中，前端界必然出现同等重量级的模块化管理方案，感谢 TC39 制定的 ES2015 模块化规范，我们已经离不开它，哪怕所有人必须使用 babel。</p><p>话说回来，标准推进的太慢，我们还是把编译工具当作常态，抱着哪怕支持了 ES2015 所有特性，babel 依然还有用的心态，将预编译进行到底。一句话，模块化仍在路上。js 模块化的矛头已经对准了 css 与 html，这两位元老也该向前卫的 js 学习学习了。</p><p>未来 css、html 的模块化会自立门户，还是赋予 js 更强的能力，让两者的模块化依附于 js 的能力呢？目前 html 有自立门户的苗头（htmlModules），而 css 迟迟没有改变，社区出现的 <code>styled-component</code> 已经用 js 将 css 模块化得很好了，最新 css 规范也支持了与 js 的变量通信，难道希望依附于 js 吗？这里希望得到大家更广泛的讨论。</p><p>我也认同，毕竟压缩、混淆、md5、或者利用 <a href="https://www.thepolyglotdeveloper.com/2015/03/create-a-random-nonce-string-using-javascript/" target="_blank" rel="noopener noreferrer">nonce</a> 属性对 script 标签加密，都离不开本地构建工具。</p><p>据说 http2 的优化中，有个最佳文件大小与数量的比例，那么还是脱离不了构建工具，前端未来会越来越复杂，同时也越来越美好。</p><p>至此，对于 javascript 模块化讨论已接近尾声，对其优缺点也基本达成了一致。前端复杂度不断提高，促使着模块化的改进，代理（浏览器、node） 的支持程度，与前端特殊性（流量、缓存）可能前端永远也离不开构建工具，新的标准会让这些工作做的更好，同时取代、增强部分特征，前端的未来是更加美好的，复杂度也更高。</p><p><strong>如果你想参与讨论，请<a href="https://github.com/dt-fe/weekly" target="_blank" rel="noopener noreferrer">点击这里</a>，每周都有新的主题，每周五发布。</strong></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/coder-study-room/Front-end-Advanced-Route/edit/master/weekly/001.精读 js 模块化发展.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-04-08T10:56:46.000Z" class="lastUpdatedDate_1WI_">4/8/2021</time> by <strong>wangweidong</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/weekly/002"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">2. 精读模态框的最佳实践 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-引言" class="table-of-contents__link">1 引言</a></li><li><a href="#2-内容概要" class="table-of-contents__link">2 内容概要</a></li><li><a href="#3-精读" class="table-of-contents__link">3 精读</a><ul><li><a href="#从语言层面到文件层面的模块化" class="table-of-contents__link">从语言层面到文件层面的模块化</a></li><li><a href="#前端三剑客的模块化展望" class="table-of-contents__link">前端三剑客的模块化展望</a></li><li><a href="#模块化标准推进速度仍然缓慢" class="table-of-contents__link">模块化标准推进速度仍然缓慢</a></li><li><a href="#http-20-对-js-模块化的推动" class="table-of-contents__link">Http 2.0 对 js 模块化的推动</a></li><li><a href="#http-20-后就不需要构建工具了吗？" class="table-of-contents__link">Http 2.0 后就不需要构建工具了吗？</a></li><li><a href="#模块化是大型项目的银弹吗？" class="table-of-contents__link">模块化是大型项目的银弹吗？</a></li><li><a href="#补充阅读" class="table-of-contents__link">补充阅读</a></li></ul></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="https://docusaurus.io/img/oss_logo.png" alt="程序员自习室开源" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="https://docusaurus.io/img/oss_logo.png" alt="程序员自习室开源" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></div><div class="footer__copyright">Copyright © 2021 程序员自习室 <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备17131802号</a></div></div></div></footer></div>
<script src="/assets/js/styles.b3f043dc.js"></script>
<script src="/assets/js/runtime~main.41f64a67.js"></script>
<script src="/assets/js/main.f6fb129f.js"></script>
<script src="/assets/js/1.46fdb85d.js"></script>
<script src="/assets/js/2.37941b87.js"></script>
<script src="/assets/js/3.8e957956.js"></script>
<script src="/assets/js/1be78505.4595a7b1.js"></script>
<script src="/assets/js/397.3ed54396.js"></script>
<script src="/assets/js/cc953bd4.972fd30a.js"></script>
<script src="/assets/js/17896441.136bed3d.js"></script>
<script src="/assets/js/fa29c8fd.50e2eb3f.js"></script>
</body>
</html>