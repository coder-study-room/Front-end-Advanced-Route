<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.72">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="前端进阶导航(2021版) Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="前端进阶导航(2021版) Blog Atom Feed"><title data-react-helmet="true">163. 精读《Spring 概念》 🦖 前端进阶导航(2021版)</title><meta data-react-helmet="true" property="og:url" content="https://coder-study-room.github.io/weekly/163"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-weekly-current"><meta data-react-helmet="true" property="og:title" content="163. 精读《Spring 概念》 🦖 前端进阶导航(2021版)"><meta data-react-helmet="true" name="description" content="spring 是 Java 非常重要的框架，且蕴含了一系列设计模式，非常值得研究，本期就通过 Spring 学习 这篇文章了解一下 spring。"><meta data-react-helmet="true" property="og:description" content="spring 是 Java 非常重要的框架，且蕴含了一系列设计模式，非常值得研究，本期就通过 Spring 学习 这篇文章了解一下 spring。"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://coder-study-room.github.io/weekly/163"><link data-react-helmet="true" rel="alternate" href="https://coder-study-room.github.io/weekly/163" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://coder-study-room.github.io/weekly/163" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.f86f321e.css">
<link rel="preload" href="/assets/js/styles.b3f043dc.js" as="script">
<link rel="preload" href="/assets/js/runtime~main.41f64a67.js" as="script">
<link rel="preload" href="/assets/js/main.f6fb129f.js" as="script">
<link rel="preload" href="/assets/js/1.46fdb85d.js" as="script">
<link rel="preload" href="/assets/js/2.37941b87.js" as="script">
<link rel="preload" href="/assets/js/3.8e957956.js" as="script">
<link rel="preload" href="/assets/js/1be78505.4595a7b1.js" as="script">
<link rel="preload" href="/assets/js/397.3ed54396.js" as="script">
<link rel="preload" href="/assets/js/cc953bd4.972fd30a.js" as="script">
<link rel="preload" href="/assets/js/17896441.136bed3d.js" as="script">
<link rel="preload" href="/assets/js/2b66eba9.aeed0fa2.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_2qcr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">前端进阶导航(2021版)</strong></a><a class="navbar__item navbar__link" href="/docs/">进阶</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/weekly/">精读</a><a class="navbar__item navbar__link" href="/interview/">面试</a></div><div class="navbar__items navbar__items--right"><a href="https://juejin.cn/user/149189280672616/posts" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">掘金</a><a href="https://www.itdongdong.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">博客</a><a href="https://www.aliyun.com/minisite/goods?userCode=656jmlbm" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">阿里云2折</a><a href="https://github.com/coder-study-room/Front-end-Advanced-Route" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_GrZ2"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">前端进阶导航(2021版)</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">进阶</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/weekly/">精读</a></li><li class="menu__list-item"><a class="menu__link" href="/interview/">面试</a></li><li class="menu__list-item"><a href="https://juejin.cn/user/149189280672616/posts" target="_blank" rel="noopener noreferrer" class="menu__link">掘金</a></li><li class="menu__list-item"><a href="https://www.itdongdong.com" target="_blank" rel="noopener noreferrer" class="menu__link">博客</a></li><li class="menu__list-item"><a href="https://www.aliyun.com/minisite/goods?userCode=656jmlbm" target="_blank" rel="noopener noreferrer" class="menu__link">阿里云2折</a></li><li class="menu__list-item"><a href="https://github.com/coder-study-room/Front-end-Advanced-Route" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"></a></li></ul></div></div></div></nav><div class="main-wrapper main-docs-wrapper"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo sidebarWithHideableNavbar_267A"><a tabindex="-1" class="sidebarLogo_3h0W" href="/"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.svg" alt="Front-end Advanced Route Logo" class="themedImage_1VuW themedImage--dark_hz6m"><strong>前端进阶导航(2021版)</strong></a><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">前端精读</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/">1. 精读 js 模块化发展</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/002">2. 精读模态框的最佳实践</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/003">3. 精读前后端渲染之争</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/004">4. 精读AsyncAwait优越之处</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/005">5. 精读民工叔单页数据流方案</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/006">6. 精读JavaScript错误堆栈处理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/007">7. 精读 请停止 css-in-js 的行为</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/008">8. 精读入坑React前没有人会告诉你的事</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/009">9. 精读 Immutable 结构共享</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/010">10. 精读Web Components 的困境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/011">11. 精读前端调试技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/012">12. 精读 React 高阶组件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/013">13. This 带来的困惑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/014">14. 精读架构设计之 DCI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/015">15. 精读 TC39 与 ECMAScript 提案</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/016">16. CSS Animations vs Web Animations API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/017">17. 精读《如何安全地使用 React context》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/018">18. 精读《设计完美的日期选择器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/019">19. 精读《最佳前端面试题》及面试官技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/020">20. 精读 《Nestjs 文档》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/021">21. 精读《Web fonts: when you need them, when you don’t》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/022">22. 精读《V8 引擎特性带来的的 JS 性能变化》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/023">23. 精读《API设计原则》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/024">24. 精读《现代 JavaScript 概览》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/025">25. 精读《null &gt;= 0?》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/026">26. 精读加密媒体扩展（Encrypted Media Extensions，EME）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/027">27. 精读《css-in-js 杀鸡用牛刀》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/028">28. 精读《2017前端性能优化备忘录》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/029">29. 精读《JS 中的内存管理》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/030">30. 精读《Javascript 事件循环与异步》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/031">31. 精读《我不再使用高阶组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/032">32. 精读《React Router4.0 进阶概念》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/033">33. 精读《30行js代码创建神经网络》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/034">34. 精读《React 代码整洁之道》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/035">35. 精读《dob - 框架实现》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/036">36. 精读《When You “Git” in Trouble- a Version Control Story》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/037">37. 精读《how we position and what we compare》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/038">38. 精读《dob - 框架使用》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/039">39. 精读《全链路体验浏览器挖矿》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/040">40. 精读《初探 Reason 与 GraphQL》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/041">41. 精读《Ant Design 3.0 背后的故事》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/042">42. 精读《前端数据流哲学》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/043">43. 精读《增强现实与可视化》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/044">44. 精读《Rekit Studio》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/045">45. 精读《React&#x27;s new Context API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/046">46. 精读《react-rxjs》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/047">47. 精读《webpack4.0 升级指南》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/048">48. 精读《Immer.js》源码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/049">49. 精读《Compilers are the New Frameworks》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/050">50. 精读《快速上手构建 ARKit 应用》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/051">51. 精读《Elements of Web Dev》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/052">52. 精读《图解 ES 模块》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/053">53. 精读《插件化思维》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/054">54. 精读《在浏览器运行 serverRender》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/055">55. 精读《async await 是把双刃剑》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/056">56. 精读《重新思考 Redux》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/057">57. 精读《现代 js 框架存在的根本原因》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/058">58. 精读《Typescript2.0 - 2.9》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/059">59. 精读《如何利用 Nodejs 监听文件夹》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/060">60. 精读《如何在 nodejs 使用环境变量》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/061">61. 精读《React 八种条件渲染》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/062">62. 精读《JS 引擎基础之 Shapes and Inline Caches》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/063">63. 精读《React 的多态性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/064">64. 精读《手写 SQL 编译器 - 词法分析》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/065">65. 精读《手写 SQL 编译器 - 文法介绍》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/066">66. 精读《手写 SQL 编译器 - 语法分析》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/067">67. 精读《手写 SQL 编译器 - 回溯》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/068">68. 精读衡量用户体验</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/069">69. 精读《SQL vs Flux》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/070">70. 精读《手写 SQL 编译器 - 语法树》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/071">71. 精读《手写 SQL 编译器 - 错误提示》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/072">72. 精读《REST, GraphQL, Webhooks, &amp; gRPC 如何选型》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/073">73. 精读《sqorn 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/074">74. 精读《12 个评估 JS 库你需要关心的事》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/075">75. 精读《Epitath 源码 - renderProps 新用法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/076">76. 精读《谈谈 Web Workers》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/077">77. 精读《用 Reduce 实现 Promise 串行执行》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/078">78. 精读《手写 SQL 编译器 - 性能优化之缓存》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/079">79. 精读《React Hooks》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/080">80. 精读《怎么用 React Hooks 造轮子》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/081">81. 精读《使用 CSS 属性选择器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/082">82. 精读《Htm - Hyperscript 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/083">83. 精读《React16 新特性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/084">84. 精读《Typescript 3.2 新特性》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/085">85. 精读《手写 SQL 编译器 - 智能提示》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/086">86. 精读《国际化布局 - Logical Properties》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/087">87. 精读《setState 做了什么》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/088">88. 精读《Caches API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/089">89. 精读《如何编译前端项目与组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/090">90. 精读《极客公园 2019》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/091">91. 精读《正则 ES2018》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/092">92. 精读《React PowerPlug 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/093">93. 精读《syntax-parser 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/094">94. 精读《Serverless 给前端带来了什么》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/095">95. 精读《Function VS Class 组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/096">96. 精读《useEffect 完全指南》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/097">97. 精读《编写有弹性的组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/098">98. 精读《react-easy-state 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/099">99. 精读《Scheduling in React》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/100">100. 精读《V8 引擎 Lazy Parsing》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/101">101. 精读《持续集成 vs 持续交付 vs 持续部署》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/102">102. 精读《Monorepo 的优势》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/103">103. 精读《为什么专家不再关心技术细节》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/104">104. 精读《Function Component 入门》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/105">105. 精读《What&#x27;s new in javascript》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/106">106. 精读《数据之上·智慧之光 - 2018》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/107">107. 精读《Optional chaining》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/108">108. 精读《智能商业》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/109">109. 精读《Vue3.0 Function API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/110">110. 精读《Inject Instance 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/111">111. 精读《前端未来展望》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/112">112. 精读《源码学习》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/113">113. 精读《Nodejs V12》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/114">114. 精读《谁在世界中心》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/115">115.精读《Tableau 入门》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/116">116. 精读《刷新》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/117">117. 精读《Tableau 探索式模型》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/118">118. 精读《使用 css 变量生成颜色主题》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/119">119. 精读《前端深水区》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/120">120. 精读《React Hooks 最佳实践》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/121">121. 精读《前端与 BI》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/122">122. 精读《robot 源码 - 有限状态机》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/123">123. 精读《用 Babel 创造自定义 JS 语法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/124">124. 精读《用 css grid 重新思考布局》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/125">125. 精读《深度学习 - 函数式之美》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/126">126. 精读《Nuxtjs》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/127">127. 精读《React Conf 2019 - Day1》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/128">128. 精读《Hooks 取数 - swr 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/129">129. 精读《React Conf 2019 - Day2》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/130">130. 精读《unstated 与 unstated-next 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/131">131. 精读《从 0 到 1》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/132">132. 精读《正交的 React 组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/133">133. 精读《寻找框架设计的平衡点》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/134">134. 精读《我在阿里数据中台大前端》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/135">135. 精读《极客公园 IFX - 上》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/136">136. 精读《极客公园 IFX - 下》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/137">137. 精读《当我在分享的时候，我在做什么？》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/138">138. 精读《精通 console.log》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/139">139. 精读《手写 JSON Parser》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/140">140. 精读《结合 React 使用原生 Drag Drop API》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/141">141. 精读《useRef 与 createRef 的区别》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/142">142. 精读《如何做好 CodeReview》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/143">143. 精读《Suspense 改变开发方式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/144">144. 精读《Webpack5 新特性 - 模块联邦》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/145">145. 精读《React Router v6》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/146">146. 精读《React Hooks 数据流》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/147">147. 精读《@types react 值得注意的 TS 技巧》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/148">148. 精读《React Error Boundaries》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/149">149. 精读《React 性能调试》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/150">150. 精读《Deno 1.0 你需要了解的》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/151">151. 精读《@umijs use-request》源码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/152">152. 精读《recoil》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/153">153. 精读《snowpack》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/154">154. 精读《用 React 做按需渲染》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/155">155. 精读《use-what-changed 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/156">156. 精读《react-intersection-observer 源码》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/157">157. 精读《如何比较 Object 对象》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/158">158. 精读《Typescript 4》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/159">159. 精读《对低代码搭建的理解》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/160">160. 精读《函数缓存》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/161">161. 精读《可视化搭建思考 - 富文本搭建》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/162">162. 精读《Tasks, microtasks, queues and schedules》</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/weekly/163">163. 精读《Spring 概念》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/164">164. 精读《数据搭建引擎 bi-designer API-设计器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/165">165. 精读《数据搭建引擎 bi-designer API-组件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/166">166. 精读《BI 搭建 - 筛选条件》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/167">167. 精读《设计模式 - Abstract Factory 抽象工厂》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/168">168. 精读《设计模式 - Builder 生成器》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/169">169. 精读《设计模式 - Factory Method 工厂方法》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/170">170. 精读《设计模式 - Prototype 原型模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/171">171. 精读《设计模式 - Singleton 单例模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/172">172. 精读《设计模式 - Adapter 适配器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/173">173. 精读《设计模式 - Bridge 桥接模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/174">174. 精读《设计模式 - Composite 组合模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/175">175. 精读《设计模式 - Decorator 装饰器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/176">176. 精读《设计模式 - Facade 外观模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/177">177. 精读《设计模式 - Flyweight 享元模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/178">178. 精读《设计模式 - Proxy 代理模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/179">179. 精读《设计模式 - Chain of Responsibility 职责链模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/180">180. 精读《设计模式 - Command 命令模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/181">181. 精读《设计模式 - Interpreter 解释器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/182">182. 精读《设计模式 - Iterator 迭代器模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/183">183. 精读《设计模式 - Mediator 中介者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/184">184. 精读《设计模式 - Memoto 备忘录模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/185">185. 精读《设计模式 - Observer 观察者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/186">186. 精读《设计模式 - State 状态模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/187">187. 精读《设计模式 - Strategy 策略模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/188">188. 精读《设计模式 - Template Method 模版模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/189">189. 精读《设计模式 - Visitor 访问者模式》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/190">190. 精读《DOM diff 原理详解》</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/weekly/191">191. 精读《高性能表格》</a></li></ul></li></ul></div><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" role="img" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><p><a href="https://spring.io/" target="_blank" rel="noopener noreferrer">spring</a> 是 Java 非常重要的框架，且蕴含了一系列设计模式，非常值得研究，本期就通过 <a href="https://www.cnblogs.com/wmyskxz/p/8820371.html" target="_blank" rel="noopener noreferrer">Spring 学习</a> 这篇文章了解一下 spring。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="spring-为何长寿"></a>spring 为何长寿<a class="hash-link" href="#spring-为何长寿" title="Direct link to heading">#</a></h2><p>spring 作为一个后端框架，拥有 17 年历史，这在前端看来是不可思议的。前端几乎没有一个框架可以流行超过 5 年，就最近来看，react、angular、vue 三大框架可能会活的久一点，他们都是前端相对成熟阶段的产物，我们或多或少可以看出一些设计模式。然而这些前端框架与 spring 比起来还是差距很大，我们来看看 spring 到底强大在哪。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="设计模式"></a>设计模式<a class="hash-link" href="#设计模式" title="Direct link to heading">#</a></h3><p>设计模式是一种思想，不依附于任何编程语言与开发框架。比如你学会了工厂设计模式，可以在后端用，也可以转到前端用，可以在 Go 语言用，也可以在 Typescript 用，可以在 React 框架用，也可以在 Vue 里用，所以设计模式是一种具有迁移能力的知识，学会后可以受益整个职业生涯，而语言、框架则不具备迁移性，前端许多同学都把精力花在学习框架特性上，遇到前端技术迭代时期就尴尬了，这就是为什么大公司面试要问框架原理，就是看看你能否抓住一些不变的东西，所以洋洋洒洒的说上下文相关的细节也不是面试官想要的，真正想听到的是你抽象后对框架原理共性的总结。</p><p>spring 框架就用到了许多设计模式，包括：</p><p>工厂模式：用工厂生产对象实例来代替原始的 new。所谓工厂就是屏蔽实例话的细节，调用处无需关心实例化对象需要的环境参数，提升可维护性。spring 的 BeanFactory 创建 bean 对象就是工厂模式的体现。
代理模式：允许通过代理对象访问目标对象。Spring 实现 AOP 就是通过动态代理模式。
单例模式：单实例。spring 的 bean 默认都是单例。
包装器模式：将几个不同方法通用部分抽象出来，调用时通过包装器内部引导到不同的实现。比如 spring 连接多种数据库就使用了包装器模式简化。
观察者模式：这个前端同学很熟悉，就是事件机制，spring 中可以通过 ApplicationEvent 实践观察者模式。
适配器模式：通过适配器将接口转换为另一个格式的接口。spring AOP 的增强和通知就使用了适配器模式。
模板方法模式：父类先定义一些函数，这些函数之间存在调用关联，将某些设定为抽象函数等待子类继承时去重写。spring 的 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等数据库操作类使用了模版方法模式。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="全家桶"></a>全家桶<a class="hash-link" href="#全家桶" title="Direct link to heading">#</a></h3><p>spring 作为一个全面的 java 框架，提供了系列全家桶满足各种场景需求：spring mvc、spring security、spring data、spring boot、spring cloud。</p><ul><li>spring boot：简化了 spring 应用配置，约定大于配置的思维。</li><li>spring data：是一个数据操作与访问工具集，比如支持 jdbc、redis 等数据源操作。</li><li>spring cloud：是一个微服务解决方案，基于 spring boot，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力。</li><li>spring security：支持一些安全模型比如单点登录、令牌中继、令牌交换等。</li><li>spring mvc：MVC 思想的 web 框架。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="ioc"></a>IOC<a class="hash-link" href="#ioc" title="Direct link to heading">#</a></h2><p>IOC（Inverse of Control）控制反转。IOC 是 Spring 最核心部分，因为所有对象调用都离不开 IOC 模式。</p><p>假设我们有三个类：Country、Province、City，最大的类别是国家，其次是省、城市，国家类需要调用省类，省类需要调用城市类：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Country {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  private Province province;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Country(){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    this.province = new Province()</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Province {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  private City city;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Province(){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    this.city = new City()</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class City {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public City(){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // ...</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>假设来了一个需求，City 实例化时需增加人口（people）参数，我们就要改动所有类代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Country {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  private Province province;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Country(int people){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    this.province = new Province(people)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Province {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  private City city;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Province(int people){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    this.city = new City(people)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class City {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public City(int people){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // ...</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>那么在真实业务场景中，一个底层类可能被数以千计的类使用，这么改显然难以维护。IOC 就是为了解决这个问题，它使得我们可以只改动 City 的代码，而不用改动其他类的代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Country {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  private Province province;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Country(Province province){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    this.province = province</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Province {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  private City city;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Province(City city){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    this.city = city</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class City {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public City(int people){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // ...</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>可以看到，增加 <code>people</code> 属性只需要改动 city 类。然而这样做也是有成本的，就是类实例化步骤会稍微繁琐一些：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">City city = new City(1000);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Province province = new Province(city);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">Country country = new Country(province);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>这就是控制反转，由 Country 依赖 Province 变成了类依赖框架（上面的实例化代码）注入。</p><p>然而手动维护这种初始化依赖是繁琐的，spring 提供了 bean 容器自动做这件事，我们只需要利用装饰器 Autowired 就可以自动注入依赖：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Country {  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    @Autowired  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private Province province;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Province {  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    @Autowired</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public City city;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class City {  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>实际上这种自动分析并实例化的手段，不仅比手写方便，还能解决循环依赖的问题。在实际场景中，两个类相互调用是很常见的，假设现在有 A、B 类相互依赖：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class A {  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    @Autowired  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    private B b;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class B {  </span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    @Autowired</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    public A a;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>那么假设我们想获取 A 实例，会经历这样一个过程：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><div tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">获取 A 实例 -&gt; 实例化不完整 A -&gt; 检测到注入 B -&gt; 实例化不完整 B -&gt; 检测到注入 A -&gt; 注入不完整 A -&gt; 得到完整 B -&gt; 得到完整 A -&gt; 返回 A 实例</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>其实 spring 仅支持单例模式下非构造器的循环依赖，这是因为其内部有一套机制，让 bean 在初始化阶段先提前持有对方引用地址，这样就可以同时实例化两个对象了。</p><p>除了方便之外，IOC 配合 spring 容器概念还可以使获取实例时不用关心一个类实例化需要哪些参数，只需要直接申明获取即可，这样在类的数量特别多，尤其是大量代码不是你写的情况下，不需要阅读类源码也可以轻松获取实例，实在是大大提升了可维护性。</p><p>说到这就提到了 Bean 容器，在 spring 概念中，Bean 容器是对 class 的加强，如果说 Class 定义了类的基本含义，那 Bean 就是对类进行使用拓展，告诉我们应该如何实例化与使用这个类。</p><p>举个例子，比如利用注解描述的这段 Bean 类：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Configuration</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class CityConfig {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  @Scope(&quot;prototype&quot;)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  @Lazy</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public City city() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    return new City()</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>可以看到，额外描述了是否延迟加载，是否单例，初始化与析构函数分别是什么等等。</p><p>下面给出一个从 Bean 获取实例的例子，采用比较古老的 xml 配置方式：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public interface City {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  Int getPeople();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class CityImpl implements City {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public Int getPeople() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    return 1000;</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>接下来用 xml 描述这个 bean：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly xml"><div tabindex="0" class="prism-code language-xml codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token prolog" style="color:rgb(0, 0, 128)">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain"></span><span class="token tag punctuation" style="color:rgb(36, 41, 46)">&lt;</span><span class="token tag" style="color:rgb(78, 201, 176)">beans</span><span class="token tag" style="color:rgb(78, 201, 176)"> </span><span class="token tag attr-name namespace" style="color:rgb(156, 220, 254)">xmlns:</span><span class="token tag attr-name" style="color:rgb(156, 220, 254)">xsi</span><span class="token tag attr-value punctuation attr-equals" style="color:rgb(36, 41, 46)">=</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag attr-value" style="color:rgb(78, 201, 176)">http://www.w3.org/2001/XMLSchema-instance</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag" style="color:rgb(78, 201, 176)"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token tag" style="color:rgb(78, 201, 176)">  </span><span class="token tag attr-name" style="color:rgb(156, 220, 254)">xmlns</span><span class="token tag attr-value punctuation attr-equals" style="color:rgb(36, 41, 46)">=</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag attr-value" style="color:rgb(78, 201, 176)">http://www.springframework.org/schema/beans</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag" style="color:rgb(78, 201, 176)"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token tag" style="color:rgb(78, 201, 176)">  </span><span class="token tag attr-name namespace" style="color:rgb(156, 220, 254)">xsi:</span><span class="token tag attr-name" style="color:rgb(156, 220, 254)">schemaLocation</span><span class="token tag attr-value punctuation attr-equals" style="color:rgb(36, 41, 46)">=</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag attr-value" style="color:rgb(78, 201, 176)">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag" style="color:rgb(78, 201, 176)"> </span><span class="token tag attr-name" style="color:rgb(156, 220, 254)">default-autowire</span><span class="token tag attr-value punctuation attr-equals" style="color:rgb(36, 41, 46)">=</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag attr-value" style="color:rgb(78, 201, 176)">byName</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag punctuation" style="color:rgb(36, 41, 46)">&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  </span><span class="token tag punctuation" style="color:rgb(36, 41, 46)">&lt;</span><span class="token tag" style="color:rgb(78, 201, 176)">bean</span><span class="token tag" style="color:rgb(78, 201, 176)"> </span><span class="token tag attr-name" style="color:rgb(156, 220, 254)">id</span><span class="token tag attr-value punctuation attr-equals" style="color:rgb(36, 41, 46)">=</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag attr-value" style="color:rgb(78, 201, 176)">city</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag" style="color:rgb(78, 201, 176)"> </span><span class="token tag attr-name" style="color:rgb(156, 220, 254)">class</span><span class="token tag attr-value punctuation attr-equals" style="color:rgb(36, 41, 46)">=</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag attr-value" style="color:rgb(78, 201, 176)">xxx.CityImpl</span><span class="token tag attr-value punctuation" style="color:rgb(36, 41, 46)">&quot;</span><span class="token tag punctuation" style="color:rgb(36, 41, 46)">/&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain"></span><span class="token tag punctuation" style="color:rgb(36, 41, 46)">&lt;/</span><span class="token tag" style="color:rgb(78, 201, 176)">beans</span><span class="token tag punctuation" style="color:rgb(36, 41, 46)">&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><code>bean</code> 支持的属性还有很多，由于本文并不做入门教学，就不一一列举了，总之 <code>id</code> 是一个可选的唯一标志，接下来我们可以通过 <code>id</code> 访问到 city 的实例。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class App {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public static void main(String[] args) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 从 context 中读取 Bean，而不 new City()</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    City city = context.getBean(City.class);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    System.out.println(city.getPeople());</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>可以看到，程序任何地方使用 city 实例，只需要调用 <code>getBean</code> 函数，就像一个工厂把实例化过程给承包了，我们不需要关心 City 构造函数要传递什么参数，不需要关心它依赖哪些其他的类，只要这一句话就可以拿到实例，是不是在维护项目时省心了很多。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="aop"></a>AOP<a class="hash-link" href="#aop" title="Direct link to heading">#</a></h2><p>AOP（Aspect Oriented Program）面向切面编程。</p><p>AOP 是为了解决主要业务逻辑与次要业务逻辑之间耦合问题的。主要业务逻辑比如登陆、数据获取、查询等，次要业务逻辑比如性能监控、异常处理等等，次要业务逻辑往往有：不重要、和业务关联度低、贯穿多处业务逻辑的特性，如果没有好的设计模式，只能在业务代码里将主要逻辑与次要逻辑混合起来，但 AOP 可以做到主要、次要业务逻辑隔离。</p><p>使用 AOP 就是在定义在哪些地方（类、方法）切入，在什么地方切入（方法前、后、前后）以及做什么。</p><p>比如说，我们想在某个方法前后分别执行两个函数计算执行时间，下面是主要业务逻辑：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component(&quot;work&quot;)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">public class Work {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public void do() {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    System.out.println(&quot;执行业务逻辑&quot;);</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>再定义切面方法：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Aspect</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">class Broker {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  @Before(&quot;execution(* xxx.Work.do())&quot;)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public void before(){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 记录开始时间</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  @After(&quot;execution(* xxx.Work.do())&quot;)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public void after(){</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 计算时间</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>再通过 xml 定义扫描下这两个 Bean，就可以在运行 <code>work.do()</code> 之前执行 <code>before()</code>，之后执行 <code>after()</code>。</p><p>还可以完全覆盖原函数，利用 <code>joinPoint.proceed()</code> 可以执行原函数：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:rgb(36, 41, 46);background-color:#f6f8fa"><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Component</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">@Aspect</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">class Broker {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  @Around(&quot;execution(* xxx.Work.do())&quot;)</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  public void around(ProceedingJoinPoint joinPoint) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 记录开始时间</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    try {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      joinPoint.proceed();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    } catch (Throwable throwable) {</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">      throwable.printStackTrace();</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">    // 计算时间</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">  }</span></div><div class="token-line" style="color:rgb(36, 41, 46)"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>关于表达式 <code>&quot;execution(* xxx.Work.do())&quot;</code> 是用正则的方式匹配，<code>*</code> 表示任意返回类型的方法，后面就不用解释了。</p><p>可以看到，我们可以在不修改原方法的基础上，在其执行前后增加自定义业务逻辑，或者监控其报错，非常适合做次要业务逻辑，且由于不与主要业务逻辑代码耦合，保证了代码的简洁，且次要业务逻辑不容易遗漏。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><p>IOC 特别适合描述业务模型，后端天然需要这一套，然而随着前端越做越重，如果某个业务场景下需要将部分业务逻辑放到前端，也是非常推荐使用 IOC 设计模式来做，这是后端沉淀了近 20 年的经验，没有必要再另辟蹊径。</p><p>AOP 对前端有帮助但没有那么大，因为前端业务逻辑较为分散，如果要进行切面编程，往往用 <code>window</code> 事件监听来做会更彻底，可能这都是前端没有流行 AOP 的原因。当然前端约定大于配置的趋势下，比如打点或监控都集成到框架内部，往往也做到了业务代码无感，剩下的业务代码也就没有 AOP 的需求。</p><p>最后，spring 的低侵入式设计，使得业务代码不用关心框架，让业务代码能够快速在不同框架间切换，这不仅方便了业务开发者，更使得 spring 走向成功，这是前端还需要追赶的。</p><blockquote><p>讨论地址是：<a href="https://github.com/dt-fe/weekly/issues/265" target="_blank" rel="noopener noreferrer">精读《Spring 概念》· Issue #265 · dt-fe/weekly</a></p></blockquote><p><strong>如果你想参与讨论，请 <a href="https://github.com/dt-fe/weekly" target="_blank" rel="noopener noreferrer">点击这里</a>，每周都有新的主题，周末或周一发布。前端精读 - 帮你筛选靠谱的内容。</strong></p><blockquote><p>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener noreferrer">创意共享 3.0 许可证</a>）</p></blockquote></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/coder-study-room/Front-end-Advanced-Route/edit/master/weekly/163.精读《Spring 概念》.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-04-09T10:12:47.000Z" class="lastUpdatedDate_1WI_">4/9/2021</time> by <strong>wangweidong</strong></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/weekly/162"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 162. 精读《Tasks, microtasks, queues and schedules》</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/weekly/164"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">164. 精读《数据搭建引擎 bi-designer API-设计器》 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#spring-为何长寿" class="table-of-contents__link">spring 为何长寿</a><ul><li><a href="#设计模式" class="table-of-contents__link">设计模式</a></li><li><a href="#全家桶" class="table-of-contents__link">全家桶</a></li></ul></li><li><a href="#ioc" class="table-of-contents__link">IOC</a></li><li><a href="#aop" class="table-of-contents__link">AOP</a></li><li><a href="#总结" class="table-of-contents__link">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="https://docusaurus.io/img/oss_logo.png" alt="程序员自习室开源" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="https://docusaurus.io/img/oss_logo.png" alt="程序员自习室开源" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></div><div class="footer__copyright">Copyright © 2021 程序员自习室 <a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备17131802号</a></div></div></div></footer></div>
<script src="/assets/js/styles.b3f043dc.js"></script>
<script src="/assets/js/runtime~main.41f64a67.js"></script>
<script src="/assets/js/main.f6fb129f.js"></script>
<script src="/assets/js/1.46fdb85d.js"></script>
<script src="/assets/js/2.37941b87.js"></script>
<script src="/assets/js/3.8e957956.js"></script>
<script src="/assets/js/1be78505.4595a7b1.js"></script>
<script src="/assets/js/397.3ed54396.js"></script>
<script src="/assets/js/cc953bd4.972fd30a.js"></script>
<script src="/assets/js/17896441.136bed3d.js"></script>
<script src="/assets/js/2b66eba9.aeed0fa2.js"></script>
</body>
</html>